# 阻塞与非阻塞
> 怎麼理解阻塞和非阻塞的區別？

**1. 同步和異步**　　
同步和異步關注的是消息通信機制( synchronous communication/ asynchronous communication)  
所謂同步，就是在發出一個*調用*時，在沒有得到結果之前，該-調用-就不返回。但是一旦調用返回，就得得到返回值了。　　
換句話說，就是由-調用者-主動等待這個-調用-結果。　　
而異步則是相反，-調用-在發出之後，這個調用就直接得到結果。而是在-調用-發出後，-換句話說-當一個異步過程調用發出後，調用者不會立即得到結果。而是在-調用-發出後，-被調用者-通過狀態、通知來通知調用者，或通過灰調函數處理這個調用。　　

典型的異步編程比如Node.js  

**2. 阻塞和非阻塞**  
阻塞和非阻塞關注的是程序在等待調用結果(消息，返回值)是的狀態。  
阻塞調用是指調用結果返回之前，但錢線程會被掛起。調用線程指頭在得到結果之後才會返回。  
非阻塞調用指在不能立刻得到結果之前，該調用不會阻塞當前線程。  　

## 阻塞與非阻塞、同步與異步I/O模型
###　I/O 模型：

**1. Linux 下的五中I/O模型**  
- 阻塞I/O
- 非阻塞I/O
- I/O 復用
- 信號驅動I/O
- 異步I/O
前四種都是同步，只有最後一種才是異步IO；  

**2. Windows 的異步I/O模型有下面六種**  
- select選擇模型
- WSAAsyncSelect 異步選擇模型
- WSAEventSelect 事件選擇模型
- Overlapped I/O 事件通知模型  
- Overlapped I/O 完成例程模型
- IOCP 模型

### Linux 的幾種I/O 模型介紹：
**1. 阻塞I/O模型**  
> 進程會一直阻塞,知道數據拷貝完成  
應用程序調用一個I/O函數,導致應用程序阻塞,等待數據準備好.如果數據沒有準備好,一直等待...數據準備好了,從內核拷貝到用戶空間,I/O函數返回成功指示.  

![阻塞I/O模型圖](http://img.blog.csdn.net/20140602181230593)

可能阻塞套接字的Windows Sockets API調用分爲以下四種:  
1. 輸入操作:  
recv(),recvfrom(),WSARecv() 和 WSARecvfrom() 函數. 以阻塞套接字爲參數調用該函數接收數據.如果此時套接字緩衝區內沒有數據刻度,則調用線程在數據到來前一直睡覺.  
2. 輸出操作:  
send(), sendto(), WSASend() 和 WSASendto() 函數.以阻塞套接字爲參數調用該函數發送數據.如果套接字緩衝區沒有可用空間,縣城會一直睡覺,直到有空間.  
3. 接受連接:  
accept() 和 WSAAccept() 函數.以阻塞套接字爲參數調用該函數,等待接受對方的連接請求.如果此時沒有連接請求,線程就會進入睡眠狀態.  
4. 外出連接:  
connect() 和 WSAConnect() 函數. 對於TCP鏈接,客戶端以阻塞套接字爲參數,調用該函數,調用該函數向服務器發起鏈接.該函數在收到服務器的贏大前,不會返回.這意味着TCP鏈接總會等待至少到服務器的一次往返時間.  

**2. 非阻塞I/O模型**   
**3. I/O復用模型**  
**4. 信號驅動I/O模型**   
**5. 異步I/O模型**  
**6. 五種I/O模型比較**    

