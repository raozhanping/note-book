{"./":{"url":"./","title":"速记","keywords":"","body":"速记 TODO 按位操作 代理(Proxy)和反射(Reflection) Ubuntu开发环境安装 Jest DOCS semantic-release git commit format (): // 空一行 //type（必需）、scope（可选）和subject（必需） //(可选) type用于说明 commit 的类别，只允许使用下面8个标识。 br: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 revert: feat(pencil): add 'graphiteWidth' option (撤销之前的commit) getBoundingClientRect dispatchEvent 创建(createEvent)-初始(init*Event)-分派(dispatchEvent) JS滚轮事件(mousewheel/DOMMouseScroll) 兼容差异 onmousewheel(Other) / DOMMouseScroll(FF) 包括IE6在内的浏览器是使用onmousewheel，而FireFox浏览器一个人使用DOMMouseScroll. 经自己测试，即使现在FireFox 19下，也是不识onmousewheel event.wheelDelta(Other) / event.detail(FF) 需要注意的是，FireFox浏览器的方向判断的数值的正负与其他浏览器是相反的。FireFox浏览器向下滚动是正值，而其他浏览器是负值。 渲染10k条记录 Large number of DOM nodes make rendering slow JavaScript arrays can handle large data sets Looping through large arrays is fast Sorting arrays by providing custom function to Array.sort() is fast eval() is slow, should not be used in large loops To achieve smooth scrolling render a few hidden records on top and bottom outside of the visible area window.requestIdleCallback() 会在浏览器空闲时期依次调用函数， 这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟敏感的事件产生影响。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序 var handle = window.requestIdleCallback(callback[, options]) window.cancelIdleCallback(handle) powered by Gitbook文件修改于： 2019-10-15 10:58:01 "},"src/interview.html":{"url":"src/interview.html","title":"前端面试","keywords":"","body":"前端面试 面试过程 工作履历 项目经验 技术基础 编程思路 面试者问答 前端面试题 html doctype 作用? 严格模式与混杂模式如何区分？它们有何意义? 列出常见的标签，并简单介绍这些标签用在什么场景？ 阐述下什么是块标签和内联标签，并写出5种块（block）标签，写出5种内联（inline）标签 如何在 html 页面上展示 这几个字符？ css 阐述display分别为block, inline，inline-block的区别，(提示：在宽高、pading、margin上的区别） 阐述visibility:hidden和display:none的区别 CSS选择器有哪些，举例写出如下选择器的实现方式 伪类选择器有哪些? 写出两种定宽div水平居中的方式(提示：margin和position方式) CSS优先级算法如何计算？(提示：从!important注释，元素内部style属性，...class类等选择器角度去阐述） 详细描述postion：absolute，fixed，relative，static的区别（提示：描述原点是怎么定位的） 写出.clearfix 消除浮动的代码并阐述其原理 如何让 Chrome 浏览器显示小于 12px 的文字？ javascrit 介绍js的基本数据类型 描述”==“和“===”的区别 在做if判断时，空字符串(‘’)，空对象(null)，空数组([])，undefined，哪些为true哪些为false 写一段代码，分别使用call和apply向一个数组中添加一个元素 简述什么是闭包，和闭包的应用场景 阐述es6新特性有哪些 let, var, const 区别 阐述下react 生命周期(提示： 从生命周期钩子函数解释) setState什么时候是同步，什么时候是异步的 浏览器是如何渲染页面的？ 阐述下浏览器的事件循环机制 工程化 webpack 是如何打包文件的，或者阐述其基本配置有哪些分别有什么作用？ 常见的loader 和 plugin有哪些，他们的作用分别是什么？ 如何利用 webpack 来优化前端性能？ 编程题 实现一个方法，使得数组[1, 2, 3, 4, 5, 6, 7]能够乱序输出 实现一个方法，对字符串'abbbcccccbb'压缩输出'a3b5c2b' 实现对象的深拷贝 编程使得 console.log(a == 1 && a == 2 && a == 3) 输出 true 根据金额总数计算出最小货币数(count) 数据结构与算法 有效的括号 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 用两个栈实现队列 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1，2，3，4，5 是某栈的压入顺序，序列 4，5，3，2，1是该压栈序列对应的一个弹出序列，但4，3，5，1，2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 包含 min 函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/html-css.html":{"url":"src/html-css.html","title":"HTML / CSS","keywords":"","body":"HTML / CSS powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-html.html":{"url":"src/hc-html.html","title":"HTML","keywords":"","body":"HTML iframe 1. iframe 常用属性 frameborder:是否显示边框，1(yes),0(no) height:框架作为一个普通元素的高度，建议在使用css设置。 width:框架作为一个普通元素的宽度，建议使用css设置。 name:框架的名称，window.frames[name]时专用的属性。 scrolling:框架的是否滚动。yes,no,auto。 src：内框架的地址，可以使页面地址，也可以是图片的地址。 srcdoc , 用来替代原来HTML body里面的内容。但是IE不支持, 不过也没什么卵用 sandbox: 对iframe进行一些列限制，IE10+支持 2. iframe 同域 2.1 获取 iframe 里的内容 iframe.contentWindow, 获取iframe的window对象 iframe.contentDocument, 获取iframe的document对象 这两个API只是DOM节点提供的方式(即getELement系列对象)另外更简单的方式是，结合Name属性，通过window提供的frames获取 Your browser does not support iframes. console.log(window.frames['ifr1'].window); console.dir(document.getElementById(\"ifr1\").contentWindow); 2.2 在 iframe 中获取父级内容 同理，在同域下，父页面可以获取子iframe的内容，那么子iframe同样也能操作父页面内容。 window.parent 获取上一级的window对象，如果还是iframe则是该iframe的window对象 window.top 获取最顶级容器的window对象，即，就是你打开页面的文档 window.self 返回自身window的引用。可以理解 window===window.self 2.3 iframe 的轮询 话说在很久很久以前，我们实现异步发送请求是使用iframe实现的~! 怎么可能!!! 真的史料为证(自行google), 那时候为了不跳转页面，提交表单时是使用iframe提交的。现在，前端发展尼玛真快，websocket,SSE,ajax等，逆天skill的出现，颠覆了iframe, 现在基本上只能活在IE8,9的浏览器内了。 但是，宝宝以为这样就可以不用了解iframe了,而现实就是这么残酷，我们目前还需要兼容IE8+。所以，iframe 实现长轮询和长连接的trick 我们还是需要涉猎滴。 2.4 iframe 的长轮询 var iframeCon = docuemnt.querySelector('#container'), text; //传递的信息 var iframe = document.createElement('iframe'), iframe.id = \"frame\", iframe.style = \"display:none;\", iframe.name=\"polling\", iframe.src=\"target.html\"; iframeCon.appendChild(iframe); iframe.onload= function(){ var iloc = iframe.contentWindow.location, idoc = iframe.contentDocument; setTimeout(function(){ text = idoc.getElementsByTagName('body')[0].textContent; console.log(text); iloc.reload(); //刷新页面,再次获取信息，并且会触发onload函数 },2000); } 这样就可以实现ajax的长轮询的效果。 当然，这里只是使用reload进行获取，你也可以添加iframe和删除iframe的方式，进行发送信息，这些都是根据具体场景应用的。另外在iframe中还可以实现异步加载js文件，不过，iframe和主页是共享连接池的，所以还是很蛋疼的，现在基本上都被XHR和hard calllback取缔了，这里也不过多介绍了。 2.5 自适应广告 2.6 自适应 iframe allowtransparency true or false 是否允许iframe设置为透明，默认为false allowfullscreen true or false 是否允许iframe全屏，默认为false 2.7 X-Frame-Options X-Frame-Options是一个相应头，主要是描述服务器的网页资源的iframe权限。目前的支持度是IE8+(已经很好了啊喂)有3个选项: DENY：当前页面不能被嵌套iframe里，即便是在相同域名的页面中嵌套也不允许,也不允许网页中有嵌套iframe SAMEORIGIN：iframe页面的地址只能为同源域名下的页面 ALLOW-FROM：可以在指定的origin url的iframe中加载 X-Frame-Options其实就是将前端js对iframe的把控交给服务器来进行处理。 //js if(window != window.top){ window.top.location.href = window.location.href; } //等价于 X-Frame-Options: DENY //js if (top.location.hostname != window.location.hostname) { 　　　　top.location.href =window.location.href; } //等价于 X-Frame-Options: SAMEORIGIN 该属性是对页面的iframe进行一个主要限制，不过，涉及iframe的header可不止这一个，另外还有一个 Content Security Policy, 他同样也可以对iframe进行限制，而且，他应该是以后网页安全防护的主流。 2.8 sandbox allow-forms 允许进行提交表单 allow-scripts 运行执行脚本 allow-same-origin 允许同域请求,比如ajax,storage allow-top-navigation 允许iframe能够主导window.top进行页面跳转 allow-popups 允许iframe中弹出新窗口,比如,window.open,target=\"_blank\" allow-pointer-lock 在iframe中可以锁定鼠标，主要和鼠标锁定有关 3. resolve iframe跨域 浏览器判断你跨没跨域，主要根据两个点。 一个是你网页的协议(protocol)，一个就是你的host是否相同，即，就是url的首部 3.1 H5的CDM跨域与iframe 如果你设置的iframe的域名和你top window的域名完全不同。 则可以使用 CDM(cross document messaging)进行跨域消息的传递。该API的兼容性较好 ie8+都支持. 发送消息: 使用 postmessage方法 接受消息: 监听message事件 3.2 postmessage 该方法挂载到window对象上，即，使用 window.postmessage()调用.该方法接受两个参数:postMessage(message, targetOrigin):message: 就是传递给iframe的内容, 通常是string,如果你想传object对象也可以.(stringify)targetOrigin: 接受你传递消息的域名，可以设置绝对路径，也可以设置\"\"或者\"/\"。 表示任意域名都行，\"/\"表示只能传递给同域域名。当targetOrigin接受到message消息之后,会触发message事件。 message提供的event对象上有3个重要的属性，data,origin,source. data：postMessage传递进来的值 origin：发送消息的文档所在的域 source：发送消息文档的window对象的代理，如果是来自同一个域，则该对象就是window，可以使用其所有方法，如果是不同的域，则window只能调用postMessage()方法返回信息 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-css.html":{"url":"src/hc-css.html","title":"CSS","keywords":"","body":"CSS 弹出框(modal) 抽屉式弹出 .modal { &.fade .modal-dialog { -webkit-transition: -webkit-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: translate(100%, 0); -ms-transform: translate(100%, 0); -o-transform: translate(100%, 0); transform: translate(100%, 0); } &.in .modal-dialog { -webkit-transform: translate(0, 0); -ms-transform: translate(0, 0); -o-transform: translate(0, 0); transform: translate(0, 0); } } CSS基础布局--BFC BFC,全称 Block Formatting Context，翻译成块级格式化上下文，它就是一个环境，HTML元素在这个环境中按照一定规则进行布局 BFC的生成 浮动元素、 绝对定位元素， 块级元素以及块级容器(比如inline-block、table-cell、table-capation) overflow值不为visible的块级盒子 root元素会自动生成一个BFC powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-css-modules.html":{"url":"src/hc-css-modules.html","title":"CSS Modules","keywords":"","body":"CSS Modules powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-cm-readme.html":{"url":"src/hc-cm-readme.html","title":"CSS Modules","keywords":"","body":"CSS Modules A CSS Module is a CSS file in which all class names and animation names are scoped locally by default. All URLs (url(...)) and @import are in module request format (./xxx and ../xxx means relative, xxx and xxx/yyy means in modules folder, i.e. in node_modules). CSS Modules compile to a low-level interchange format called ICSS or Interoperable CSS, but are written like normal CSS files: When importing the CSS Module from a JS Module, it exports an object with all mappings from local names to global names. Naming For local class names cameCase naming is recommended, but not enforced. Exceptions :global switches to global scope for the current selector respective identifier. :global(.xxx) respective @keyframes:global(xxx) declares the stuff in parenthesis in the global scope. Similarly, :local and :local(...) for local scope. if the selector is switched into global mode, global mode is activated for the rules.(This allows us to make animation:abc; local) Example: .localA :global .global-b .global-c :local(.localD.localE) .global-d Composition It's possible to compose selectors. .className { color: green; background: red; } .otherClassName { composes: className; color: yellow; } There can be multipe composes rules, but composes rules must be before other rules. Extending works only for local-scoped selectors and only if the selector is a single class name. When a class name composes another class name, the CSS Module exports both class names for the local class. This can add up to multiple class names. It's possible to compose multiple classes with compose: classNameA classNameB. Dependencies It's possible to compose class names from other CSS Modules. .otherClassName { composes: className from \"./style.css\"; } Note that when composing multiple classes from different files the order of appliance is undefined. Make sure to not define different values for the same property in multiple class names from different files when they are composed in a single class. Note that composing should not form a circular dependency. Elsewise it's undefined whether properties of a rule override properties of a composed rule. The module system may emit an error. Usage with preprocessors Perprocessors can make it easy to define a vlock global or local.i.e. with less.js :global { .global-class-name { color: green; } } Why? modular and reusable CSS! No more conflicts. Explicit dependencies. No global scope. Implementations webpack Webpack's css-loader in module mode replaces every local-scoped identifier with a global unique name (hashed from module name and local identifier by default) and exports the used identifier. Extending adds the source class name(s) to the exports. Extending from other modules first imports the other module and then adds the class name(s) to the exports. Server-side and static websites PostCSS-Modules allow to use CSS Modules for static builds and the server side with Ruby, PHP or any other language or framework. powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-cm-usage.html":{"url":"src/hc-cm-usage.html","title":"CSS Modules Usage","keywords":"","body":"CSS Modules 为了让 CSS 能够适用软件工程方法，程序员想了各种方法，让他变得像一门编程语言。从最早的 Less、 SASS，到后来的 PostCSS，再到最近的 CSS in JS，都是为了解决这个问题。 而 CSS Modules 不同于上述。他不是将 CSS 改造成编程语言，而是功能很单纯，只加入了局部作用域和模块依赖，这恰恰是网页组件最急需的功能。 局部作用域 CSS 的规则都是全局的，任何一个组件的样式规则，都对整个网页有效。 产生局部作用域的唯一方法，就是使用一个独一无二的 class 的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。 import React from 'react'; import style form './App.css'; export default () => { return ( Hello World! ); } 全局作用域 CSS Modules 允许使用 :global(.className)的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成hash字符串。 .title { color: red; } :global(.title) { color: green; } import React from 'react'; import styles from './App.css'; export defalut () => { return ( Hello World ); } 定制哈希类明 css-loader 默认的哈希算法是[hash:base64]，这会将.title编译成._3zyde4l1yATCOkgn-DBWEL这样的字符串。 module: { loaders: [ // ... { test: /\\.css$/, loader: \"style-loader!css-loader?modules&localIdentName=[path][name]---[local]---[hash:base64:5]\" }, ] } Class的组合 在 CSS Modules中，一个选择器可以继承另一个选择器的规则，这称为“组合”（compositoion）。 .className { background-color: blue; } .title { composes: className; color: red; } 输入其他模块 选择器也可以继承其他CSS文件里面的规则。 .title { composes: className from './another.css'; color: red; } 输入变量 CSS Modules 支持使用变量，不过需要安装 PostCSS 和 postcss-modules-values. 把 post-loader 加入 webpack.config.js. var values = require('postcss-modules-values'); module.exports = { entry: __dirname + '/index.js', output: { publicPath: '/', filename: './bundle.js' }, module: { loaders: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'stage-0', 'react'] } }, { test: /\\.css$/, loader: \"style-loader!css-loader?modules!postcss-loader\" }, ] }, postcss: [ values ] }; powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-css-stylus.html":{"url":"src/hc-css-stylus.html","title":"Stylus","keywords":"","body":"Stylus Nesting selector nesting enables you to keep your styles DRY: body { font: 14px/1.5 Helvetica, arial, sans-serif; #logo { border-radius: 5px; } } body { font: 14px/1.5 Helvetica, arial, sans-serif; } body #logo { border-radius: 5px; } Flexible syntax body font 14px/1.5 Helvetica, arial, sans-serif button button.button input[type='button'] input[type='submit'] border-radius 5px body { font: 14px/1.5 Helvetica, arial, sans-serif; } body button, body button.button, body input[type='button'], body input[type='submit'] { border-radius: 5px; } Parent reference ul li a display: block color: blue padding: 5px html.ie & padding: 6px &:hover color: red ul li a { display: block; color: #00f; padding: 5px; } html.ie ul li a { padding: 6px; } ul li a:hover { color: #f00; } Mixins Transparent mixins Variables Block property access #prompt position: absolute top: 150px left: 50% width: 200px margin-left: -(@width / 2) #prompt { position: absolute; top: 150px; left: 50%; width: 200px; margin-left: -100px; } Robust feature-rich language -pos(type, args) i = 0 position: unquote(type) {args[i]}: args[i + 1] is a 'unit' ? args[i += 1] : 0 {args[i += 1]}: args[i += 1] is a 'unit' ? args[i += 1] : 0 absolute() -pos('absolute', arguments) fixed() -pos('fixed', arguments) #prompt absolut: top 150 left 5px width: 200px margin-left: -(@width / 2) #logo fixed: top left #prompt { position: absolute; top: 150px; left: 5px; width: 200px; margin-left: -100px; } #logo { position: fixed; top: 0; left: 0; } Iteration table for row in 1 2 3 4 5 tr:nth-chihld({row}) height: 10px * row table tr:nth-child(1) { height: 10px; } table tr:nth-child(2) { height: 20px; } ... table tr:nth-child(5) { height: 50px; } Interpolation Operators Type coercion The sprintf operator body foo: '%s / %s' % (5px 10px) foo: 'MS:WeirdStuff(opacity=%s)' % 1 foo: unquote('MS:WeirdStuff(opacity=1)') body { foo: 5px / 10px; foo: MS:WeridStuff(opacity=1); foo: MS:WeirdStuff(opacity=1); } Color operations Functions Keyword arguments Built-in functions Color BIFs powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/hc-template-nunjucks.html":{"url":"src/hc-template-nunjucks.html","title":"Nunjucks","keywords":"","body":"Nunjucks 模板 文件扩展名 任意扩展名来命名 Nunjucks 模板文件（建议 .njk）； 变量 undefined 或 null 不显示； 过滤器 模板继承 模板继承可以达到模板复用的效果，同时支持多层继承； 可以将继承的模板设为一个变量，这样可以动态指定继承的模板；这个变量既可以是个指向模板文件的字符串也可以是个模板编译后所生成的对象（需要添加上下文环境）。 super 通过调用 super 从而父级区块中的内容渲染到子区块中。 标签 if for Posts This would display if the 'item' collection were empty // 如果 items 数组是空数组的话则会渲染 else 语句中的内容 在循环中可获取一些特殊的变量： loop.index loop.index0 loop.revindex loop.revindex0 loop.first loop.last loop.length asyncEachasyncEach 为 for 的异步版本，只有当使用自定义异步模板加载器的时候才使用。 asyncAllasyncAll 和 asyncEach 类似，但 asyncAll 会并行的执行，并且每项的顺序仍然会保留。除非使用异步的过滤器、扩展或加载器，否则不要使用。 macro宏（macro） 可以定义可复用的内容，类似于编程语言中的函数. set extendsextends 用来指定模板继承，被指定的模板为父级模板 block区块（block）定义了模板片段并标示一个名字，在模板继承中使用。父级模板可指定一个区块，子模板覆盖这个区块。 includeinclude 可以引入其他的模板，可以再多模板之间共享一些小模板，如果某个模板已使用了继承那么 include 将会非常有用。在某些情况下，我们可能希望在模板文件不存在时不要抛弃异常。对于这些情况，我们可以使用 ignore missing 来略过这些异常： importimport 可加载不同的模板，可是你操作模板输出的数据，模板将会输出宏和在顶级作用域进行的赋值。被 import 进来的模板没有当前模板的上下文，所以无法使用当前模板的变量。 raw输出一些 Nunjucks 特殊的标签，可以使用 {raw} 将所有的内容输出为纯文本。 filterfilter 区块允许我们使用区块中的内容来调用过滤器。不同于使用 | 语法，他会将区块渲染处的内容传递给过滤器。 callcall 区块允许你使用标签之间的内容来调用一个宏。这在你需要给宏传入大量内容时是十分有用的。在宏中，你可以通过caller() 来获取这些内容。 关键字参数 注释 {# and... #} 空白字符控制 你可以在开始和结束区块添加（-）来去除前面和后面的空白字符。 表达式 你可以使用和 javascript 一样的字面量 运算 Nunjucks 支持运算 比较 Logic and or not 可以使用大括号来分组If 表达式 和 javascript 的三元运算符一样，可使用if 的内联表达式函数调用（function Calls） 自定义转义 全局函数 range([start], stop, [step]) cycler(item1, item2, ...itemN) joiner([separator])内置过滤器 default(value, default, [boolean]) sort(arr, reverse, caseSens, attr) striptags(value, [preserve_linebreaks]) dump(object) powered by Gitbook文件修改于： 2020-04-03 13:18:01 "},"src/js.html":{"url":"src/js.html","title":"Javascript","keywords":"","body":"Javascript powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-regular.html":{"url":"src/js-regular.html","title":"正则表达式","keywords":"","body":"正则表达式 正则表达式中的特殊字符 ? 紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符） . 小数点）匹配除换行符之外的任何单个字符 \\d 匹配一个数字 \\D 匹配一个非数字字符 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符 \\S 匹配一个非空白字符 \\w 匹配一个单字字符（字母、数字或者下划线) \\W 匹配一个非单字字符 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-es6-proxy.html":{"url":"src/js-es6-proxy.html","title":"代理(Proxy)和反射(Reflection)","keywords":"","body":"代理(Proxy)和反射(Reflection) 代理(Proxy)和反射(Reflection) 代理(Proxy) 术语(term) 语法(syntax) 参数 方法(function) handler 对象的方法 示例(example) 反射(Reflection) 引用 代理(Proxy) Proxy 对象用于定义基本操作的自定义行为(如属性查找，赋值，枚举，函数调用等) 术语(term) handler包含陷阱（traps）的占位符对象。 traps提供属性访问的方法。这类似于操作系统中捕获器的概念。 target代理虚拟化的对象。它通常用作代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。 语法(syntax) let p = new Proxy(target, handler); 参数 target Object | Array | Function | Proxy 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler Object 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 方法(function) Proxy.revacable()创建一个可撤销的Proxy对象 handler 对象的方法 handler 对象是一个占位符对象，它包含Proxy的捕获器。 示例(example) 反射(Reflection) 引用 MDN-Proxy powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-type-conversion.html":{"url":"src/js-type-conversion.html","title":"类型转换","keywords":"","body":"类型转换 js 中的那些隐式转换和强制转换 数据类型 类型介绍 Number Boolean String Undefined Null Object Symbol(es6定义的) typeof 返回值 number boolean string object undefined object function symbol 强制转换 通过String(), Number(), Boolean()函数强制转换 parseInt() -> 转换到第一个不是数字为止，一个都没有返回 NAN 隐式转换 规则 转换成 String 字符串连接符 转换成 Number 自增/自减运算符(++|--) 算术运算符(+-*/) 关系运算符(>|=| 转成 Boolean 常见的隐式转换 基本类型 注意字符串连接符与算数运算符的区别 字符串连接符： 只要+号两边存在字符串 算术运算符+： 两边都是数字 关系运算符会把其他数据类型转换成Number之后比较 两边都是字符串时，按照字符串对应的unicode编码转成数字比较 两边都是字符串，且字符串是多个字符时。从左往右依次比较 Object类型 先转成String，然后再转成Number 先用 valueOf() 方法获取其原始值，如果原始值不是Number类型，则用toString() 方法转成String 再将String转成Number运算 Array.prototype.toString.call([]) === '' Object.prototype.toString.call({}) === '[object Object]' powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-bitwise-operation.html":{"url":"src/js-bitwise-operation.html","title":"按位操作","keywords":"","body":"按位操作 我们经常可以看到混合的赋值操作，算术操作和逻辑操作的 javascript 代码，但是，按位操作的代码却不是很常见，接下来让我们一探究竟， javascript 中的按位操作符 按位操作符 ~ (按位非) & (按位与) | (按位或) ^ (按位异或) >> (有符号右移) >>> (无符号右移) 引用 JavaScript中按位操作符的有趣应用 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-data-view.html":{"url":"src/js-data-view.html","title":"数据可视化","keywords":"","body":"数据可视化 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-track.html":{"url":"src/js-track.html","title":"数据采集","keywords":"","body":"数据采集 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-track-codeless.html":{"url":"src/js-track-codeless.html","title":"无(全)埋点","keywords":"","body":"Codeless Tracking 一、背景 二、什么是无埋点？ 三、关键技术 1. 基础代码 2. 页面的唯一标识 3. 元素的唯一标识 4. 如何查找元素 5. 标记元素时的高亮效果和可视化交互实现 -6. 配置工具中如何控制页面的跳转 四、总结 五、参考资料一、背景 相信很多人都接触过“埋点”这个概念，无论是前端还是后端开发，我们都可以使用这门技术来生产出一些运营性质的原始数据（接口耗时、程序安装/启动、用户交互行为等等），然后分析它们得到一些抽象指标（例如留存率、转化率），进而决定产品运营或者代码优化的方向。现在业界有许多比较知名数据平台，比如Google Analytics、Facebook Pixel、Mixpanel、GrowingIO、诸葛IO、TalkingData、神策数据等数不胜数一大票，这些平台有单纯做数据分析的，也有服务于特定领域例如广告监测转化的，都提供了多端（Android、iOS、Web、小程序、ReactNative）的埋点SDK和比较全面的BI服务。这一两年，不少平台都开始宣传一种叫“无埋点”的技术，下面以Web端为例，揭开它的神秘面纱。 二、什么是无埋点？ “无埋点”在国外一些平台被叫做Codeless Tracking，顾名思义就是可以写“更少”的埋点代码。而“代码埋点”一般需要开发人员编写代码，监听某个html元素的产生的事件，然后调用上报数据的接口，发送数据。而无埋点则可以由非技术人员（例如运营、产品），在可视化的工具中作出配置，然后就可以将html元素中产生的行为上报到后台。下面是Mixpanel平台的可视化工具的截图。 在这个工具里，需要首先输入页面的url，页面加载完成后，会出现可视化配置的工具条。点击创建事件，就可以进入元素选择模式，用鼠标点击页面上的某个元素（例如button、a这些element），就可以在弹出的对话框里面，设置这个事件的名称（比如叫TEST）。保存这个配置之后，如果页面在浏览器中被浏览，刚才配置的那个按钮发生点击时，就会向后台上报一个TEST事件。我们还可以设置上报TEST事件的时候，带上一些属性（properties），这些属性同样也是在页面中用鼠标去选择，然后保存起来的。看到这里，首先从产品层面上，我们比较具体的了解到“无埋点”到底是干什么的了，无埋点就是用可视化工具配置页面中需要被监测的元素，并设置这个元素产生行为的时候需要上报的数据。但是还有非常关键的一点必须提到，要让“无埋点”工作起来，页面里面还是必须嵌入了一段JS SDK的基础代码，只是不需要再去调用SDK具体的数据上报接口罢了。 所以，“无埋点”技术的关键是： 操作可视化配置工具，保存配置 SDK基础代码如何根据配置上报行为 下面介绍一下如何实现这两个关键。 三、关键技术 1. 基础代码 和代码埋点一样，要让“无埋点”工作起来，网页里也必须有一段“基础代码”。 (function(e,a){if(!a.__SV){varb=window;try{varc,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+\"=([^&]*)\")))?l[1]:null};g&&c(g,\"state\")&&(i=JSON.parse(decodeURIComponent(c(g,\"state\"))),\"mpeditor\"===i.action&&(b.sessionStorage.setItem(\"_mpcehash\",g),history.replaceState(i.desiredHash||\"\",e.title,j.pathname+j.search)))}catch(m){}vark,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){functione(b,a){varc=a.split(\".\");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments, 0)))}}vard=a;\"undefined\"!==typeoff?d=a[f]=[]:f=\"mixpanel\";d.people=d.people||[];d.toString=function(b){vara=\"mixpanel\";\"mixpanel\"!==f&&(a+=\".\"+f);b||(a+=\" (stub)\");returna};d.people.toString=function(){returnd.toString(1)+\".people (stub)\"};k=\"disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user\".split(\" \"); for(h=0;h 上面是Mixpanel平台的基础代码，不同平台家的这段基础代码，大同小异，都是一段IIFE形式的、压缩过的js代码，执行完成之后，在head里面插入了一个新的标签，异步去下载真正的核心SDK代码下来工作。所以并不是基础代码可以根据配置上报行为，而是基础代码会下载一段“更大”的SDK核心代码，这段代码才是SDK真正的功能实现。这样子做的好处是，基础代码很短，加载的时候不会影响到网页的性能，而且核心SDK代码的更新也不需要用户去更新这段基础代码。 2. 页面的唯一标识 在配置元素行为的时候，需要唯一标识一个页面，这样才能保证A页面的配置，不会下发给在B页面，不会导致B页面产生出A页面里配置的行为。在Web里面标识页面靠的是url，url由protocol、domain、port、path和参数组成，存储配置的时候要将url的参数提出来再存。而url的参数位置是可以变化的，比如urlA（http://a.b.com/c.html?pa=1&pb=2）和urlB（http://a.b.com/c.html?pb=2&pa=1）虽然urlA!== urlB，但是其实它们是一个页面。 3. 元素的唯一标识 唯一标识页面后，接下来就要唯一标识页面里面的元素，这样才能保证A页面中配置的元素A1可以被SDK找到，从而监听它产生的事件。 在html里面，元素是以DOM Tree组织的，如果沿着元素A1出发，一直向上记录它的parent和它在parent中的index，直到根节点body，那么就可以得到元素A1在DOM Tree中的唯一路径。 html的元素还会拥有很多属性，例如css class、id可以用来定位元素。通过Chrome开发者工具可以看到Mixpanel的可视化工具在配置元素的时候，使用的是https://github.com/Autarc/optimal-select这个库来生成element的唯一标识的。而Github上还有https://github.com/rowthan/whats-element这样的库，也可以生成元素在DOMTree中的唯一标识。 此外，还有平台在标识元素的时候，采用了xpath，这也是一个思路。 4. 如何查找元素 上面说到元素可以有唯一标识，那么有了唯一标识，就可以利用它的原理，找到这个元素。有一个很好用的API是document.querySelector()，这个API可以根据CSS选择器找到对应的元素。此外，根据元素的标识方法，还可以使用document.getElementById()、document.getElementByName()来实现元素的查找。 这里需要重点强调的是，如果页面在配置完成之后又发生了修改，导致DOM Tree发生变化，此时需要被监测的元素的唯一标识可能也会发生改变。很可能导致根据之前的配置无法找到该元素了，或者找到的并不是我们希望监测的元素，从而导致产生的事件数量发生比较明显的变化。为了数据的稳定性和准确性，应该设有相应的监测告警处理这种case，并提示用户去重新配置页面。我个人认为这是无埋点最大的缺点。 5. 标记元素时的高亮效果和可视化交互实现 这是一个比较细节的点，其实熟悉js的大牛们都知道，有无数种方式去实现鼠标移动到元素上时的类hover效果，点击元素后弹出一个对话框，让用户输入配置的信息也so easy。但是我想说的是，一旦我们采用向页面中动态添加元素的方式去实现可视化工具的交互界面，那么有可能会破坏掉页面原来的DOM Tree结构。从而导致生成元素唯一标识的时候出现误差，所以这里必须要好好处理，保证生成的元素标识不会受到影响。 我看到Mixpanel采用了CustomElement和ShadowDOM，把可视化工具所有的功能都用自定义的Web Component实现了，虽然目前只有Chrome支持Web Component，但是真的有点叼。。这样自定义的元素和交互不会对用户的网页DOM产生影响。当然，如果你的可视化工具实现做的很轻，比如只是将用户的网页放在一个iframe里面，大部分交互都交给iframe的parent页面去处理，那也可以在配置的时候，最小程度的破坏用户的网页了。 6. 配置工具中如何控制页面的跳转 当进入可视化配置状态时，我们可以让用户点击一个元素，然后弹一个对话框，让用户对这个元素进行配置。此时，如果这个元素本身的click行为是页面跳转呢？我们应该怎么处理？ 这里本质上是一个交互设计的问题。在可视化配置工具中，应该有两种基本交互操作。一种是让用户选中某一个元素，进行配置；另一种，是让用户可以触发页面原有的行为。 为什么要有第二种交互？因为我们的工具肯定要支持用户进行二级页面的可视化配置对不对？或者说，用户的页面中可能会弹出一个对话框，对话框里面有一个按钮，用户对监测这个按钮，对它做配置，对不对？简单来说，就是用户页面中原有的点击行为，可能会导致页面结构产生变化，例如跳转，页面内弹出对话框等等。 那问题就好解了，除了点击，再设计一种交互来支持用户网页中原有的点击行为不就好了。用“右键点击”或者“按住shift+点击”之类都可以。反正不要再和网页默认的交互很容易产生冲突的方式就行。 最后再提一下，之前想很久没有想明白，如何能够能防止用户点击的时候页面产生跳转。后来才知道，DOM的事件流分三个阶段：捕获、目标、冒泡。所以为了避免用户的点击产身页面跳转，给document在捕获阶段加一个listener，拦截掉这个事件的继续分发就行了。 简单的示例代码如下： document.addEventListener('click',e =>{ // 如果是按住shift的点击，那么保持原有的行为 if(e.shiftKey){ return; } // 如果是单纯的点击，那么拦截分发 e.preventDefault(); e.stopImmediatePropagation(); // 获取元素的唯一标识，然后让用户进行配置等等 this._selectElement(e.target); },true);// useCapture必须为true 四、总结 可以看到“无埋点”并不是零侵入，用户的网页中依然需要加载SDK的代码（除非你是浏览器厂商，可以在加载网页的时候，给网页加inject基础代码）。只是每一个行为事件的上报代码不需要开发人员手动编写，而是由运营人员用可视化工具配置，所以叫它“可视化埋点”也许更加合适。我们知道数据采集是数据分析的基础和先决条件，数据采集做不好，其他的东西都是空中楼阁。 这里可以小结一下“无埋点”技术的优劣。无埋点的好处是技术成本低，对用户非常友好，不需要重新部署，配置完成就可以生效。但是其缺点也非常明显，不具有代码埋点的灵活性和深度，只能采集到用户肉眼可见的数据，无法获取内存里的数据，同时也无法适应页面结构的变化，所以在实际生产中，要选择性地在合适的地方使用无埋点技术。 多扯一点产品设计和技术方案的选择，产品上是否可以支持采集内存数据呢？当然可以，比如微信小程序的“自定义分析”，就可以支持上报页面data下面的属性，这时虽然同样是可视化配置，运营人员肯定不会知道代码里面的变量名字，必须得有开发人员参与配置才行。关于页面结构发生变化之后的数据丢失，也是有方案可以破的。比如Mixpanel平台的Codeless Tracking，实际上采集了页面中所有页面的点击事件上报，然后在后台再去根据用户的配置计算转化数量。这样做的好处就是如果页面变化后，用户接到告警，修改了配置，那么用于数据上报方案是全量的，所以平台是由能力将过去的数据回溯出来的。而上面我们说的根据配置下发，查找监测指定元素，再上报数据的方案属于按需上报，数据出现误差是无法回溯的。不过全量上报数据大家也知道，太不友好了，这个数据量太大，不仅前端消耗资源多，如果为了做数据回溯，后台的存储压力也会加大，而存储的数据大部分还是无效的，这个成本有点高了。 五、参考资料 JS埋点技术分析 https://github.com/Autarc/optimal-select https://github.com/rowthan/whats-element https://www.zhihu.com/question/38000812 author： UncleChen link powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-track-expose.html":{"url":"src/js-track-expose.html","title":"模块曝光事件","keywords":"","body":"模块曝光事件 模块曝光事件 IntersectionObserver API API callback 参数 IntersectionObserverEntry 对象 Option 对象 代码示例 IntersectionObserver API 传统的实现方法是: 监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。 交叉观察器 API // 开始观察 io.observe(document.getElementById('example')); // 停止观察 io.unobserve(element); // 关闭观察器 io.disconnect(); callback 参数 callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见） IntersectionObserverEntry 对象 { time: 3893.92, rootBounds: ClientRect { bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 }, boundingClientRect: ClientRect { // ... }, intersectionRect: ClientRect { // ... }, intersectionRatio: 0.54, target: element } time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 Option 对象 threshold: 设置门槛,触发回调函数 new IntersectionObserver( entries => {/* ... */}, { threshold: [0, 0.25, 0.5, 0.75, 1] } ); root: 容器 rootMargin: 它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值,用来扩展或缩小rootBounds这个矩形的大小 代码示例 this.autoTrackExpose = function () { if (!_this.getEnableExpose()) { util.log('未开启元素曝光'); } common.bindEvent(window, 'scroll,click,resize', common.throttling(handleExposeSignal, EXPOSE_THROTTLE_TIME)); handleExposeSignal(); function handleExposeSignal () { var exposeNode = document.querySelectorAll('['+ EXPOSE_ATTR_FLAG +']'); var viewportRect = common.getViewport(); console.log(11); exposeNode.forEach(function (node) { var preStatus = node.isExposed; // 更新 isExposed node.isExposed = common.intersectRect(node.getBoundingClientRect(), viewportRect); node.nodeInfo = common.getTargetInfo(node); // 节点 destroy时需要 取消曝光心跳 preStatus ? node.isExposed ? null : exitExposeStatus(node) : node.isExposed ? inExposeStatus(node) : null; }); function updateNodeHbTime (node) { node.mHbTime = new Date().getTime(); } function inExposeStatus (node) { // 发送曝光事件 _this.trackExpose(node.nodeInfo); updateNodeHbTime(node); // 曝光心跳 var exposeHbObj = util.merge(node.nodeInfo); exposeHbObj.expTime = EXPOSE_HB_TIME; node.mTimeId = setInterval(function () { _this.trackExposeHb(exposeHbObj); // 更新 节点曝光时间 updateNodeHbTime(node); }, EXPOSE_HB_TIME * 1000); } function exitExposeStatus (node) { var exposeHbObj = util.merge(node.nodeInfo); exposeHbObj.expTime = Math.ceil((new Date().getTime() - node.mHbTime) / 1000); clearInterval(node.mTimeId); _this.trackExposeHb(exposeHbObj); } } }; powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-package.html":{"url":"src/js-package.html","title":"package","keywords":"","body":"package powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-package-axios.html":{"url":"src/js-package-axios.html","title":"axios","keywords":"","body":"axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 axios Axios 功能 Axios request 核心代码 reference Axios 功能 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF Axios request 核心代码 function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() }; } Axios.prototype.request = function request(config) { // Allow for axios('example/url'[, config]) a la fetch API if (typeof config === 'string') { config = arguments[1] || {}; config.url = arguments[0]; } else { config = config || {}; } // 合并配置 config = mergeConfig(this.defaults, config); // 请求方式，没有默认为 get config.method = config.method ? config.method.toLowerCase() : 'get'; // 重点 这个就是拦截器的中间件 var chain = [dispatchRequest, undefined]; // 生成一个 promise 对象 var promise = Promise.resolve(config); // 将请求前方法置入 chain 数组的前面 一次置入两个 成功的，失败的 this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) { chain.unshift(interceptor.fulfilled, interceptor.rejected); }); // 将请求后的方法置入 chain 数组的后面 一次置入两个 成功的，失败的 this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) { chain.push(interceptor.fulfilled, interceptor.rejected); }); // 通过 shift 方法把第一个元素从其中删除，并返回第一个元素。 while (chain.length) { promise = promise.then(chain.shift(), chain.shift()); } return promise; }; reference Axios 源码解读 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-event-loop.html":{"url":"src/js-event-loop.html","title":"Event Loop","keywords":"","body":"Event Loop 参考文献 定义 为了协调事件，用户交互，脚本，渲染，网络等，用户代理必须使用本节所述的event loop。 task 一个event loop有一个或者多个task队列。当用户代理安排一个任务，必须将该任务增加到相应的event loop的一个tsak队列中。每一个task都来源于指定的任务源，比如可以为鼠标、键盘事件提供一个task队列，其他事件又是一个单独的队列。可以为鼠标、键盘事件分配更多的时间，保证交互的流畅。 那些是 task 任务源 DOM操作任务源： 此任务源被用来相应dom操作，例如一个元素以非阻塞的方式插入文档。 用户交互任务源： 此任务源用于对用户交互作出反应，例如键盘或鼠标输入。响应用户操作的事件（例如click）必须使用task队列。 网络任务源： 网络任务源被用来响应网络活动 history traversal任务源： 当调用history.back()等类似的api时，将任务插进task队列。 总结来说task任务源： setTimeout setInterval setImmediate I/O UI rendering microtask 每一个event loop都有一个microtask队列，一个microtask会被排进microtask队列而不是task队列。有两种microtasks：分别是solitary callback microtasks和compound microtasks。规范值只覆盖solitary callback microtasks。 参考文献 从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-react.html":{"url":"src/js-react.html","title":"React","keywords":"","body":"React powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-react-preview.html":{"url":"src/js-react-preview.html","title":"React热身","keywords":"","body":"React热身 用于构建用户界面的 JavaScript 库 组件 示例组件 props propTypes state ReactDOM.render this.props.children import React, { Component } from 'react'; import propTypes from 'prop-types'; class TestComponent extends React.Component { static defaultProps = { name: 'testing component', count: 1 } static propTypes = { name: propTypes.string.isRequired } constructor() { this.state = { name: '', count: 1 }; } // 16.3 deprecated componentWilMount() { console.log('初始化阶段1'); } static getDerivedStateFromProps(nextProps, preState) { console.log('初始化阶段1') } componentDidMount() { console.log('初始化阶段2'); } componentWillUnmount() { console.log('卸载阶段1'); } // 16.3 deprecated componentWillReceiveProps(nextProps) { console.log('运行阶段1'); } shouldComponentUpdate(newProps, newState) { console.log('运行阶段2'); if (!newProps.name) { return false; } } // 16.3 deprecated componentWillUpdate(nextProps, nextState) { console.log('运行阶段3'); } getSnapshotBeforeUpdate(preProps, preState) { console.log('更新阶段') } componentDidUpdate(preProps, preState) { console.log('运行阶段4'); } handleClick() { console.log('react click 事件处理'); } render() { console.log('组件渲染了'); return ( Hello {this.props.name} 测试点击事件 ); } } ReactDOM.render( , document.getElementById('root') ); 组件生命周期函数 分三个阶段： 初始化（挂载）阶段、运行（更新）阶段、卸载阶段 React componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount React v16.0 componentDidCatch(error, info) 此生命周期在后代组件抛出错误后被调用 React v16.3 static getDerivedStateFromProps getSnapshotBeforeUpdate React v17.0 componentWillReceiveProps componentWillMount componentWillUpdate 概念 受控组件 表单数据是由 React 组件来管理 class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ''}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert('提交的名字: ' + this.state.value); event.preventDefault(); } render() { return ( 名字: ); } } 非受控组件 表单数据将交由 DOM 节点来处理 class NameForm extends React.Component { constructor(props) { super(props); this.handleSubmit = this.handleSubmit.bind(this); this.input = React.createRef(); } handleSubmit(event) { alert('A name was submitted: ' + this.input.current.value); event.preventDefault(); } render() { return ( Name: ); } } 状态提升 状态共享 无状态组件 有状态组件 高阶组件(HOC) 高阶组件是参数为组件，返回值为新组件的函数 React哲学 将设计好的 UI 划分为组件层级(单一功能原则) 用 React 创建一个静态版本 确定 UI state 的最小（且完整）表示 确定 state 放置的位置 添加反向数据流 Create React App Docs reference reactjs powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-react-vdom.html":{"url":"src/js-react-vdom.html","title":"VDOM和DOM-diff","keywords":"","body":"VDOM和DOM-diff 类型验证(prop-types) import PropTypes from 'prop-types'; MyComponent.propTypes = { // 你可以将属性声明为以下 JS 原生类型 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可被渲染的元素（包括数字、字符串、子元素或数组）。 optionalNode: PropTypes.node, // 一个 React 元素 optionalElement: PropTypes.element, // 你也可以声明属性为某个类的实例，这里使用 JS 的 // instanceof 操作符实现。 optionalMessage: PropTypes.instanceOf(Message), // 你也可以限制你的属性值是某个特定值之一 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 限制它为列举类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 一个指定元素类型的数组 optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // 一个指定类型的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 一个指定属性及其类型的对象 optionalObjectWithShape: PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number }), // 你也可以在任何 PropTypes 属性后面加上 `isRequired` // 后缀，这样如果这个属性父组件没有提供时，会打印警告信息 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 你也可以指定一个自定义验证器。它应该在验证失败时返回 // 一个 Error 对象而不是 `console.warn` 或抛出异常。 // 不过在 `oneOfType` 中它不起作用。 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); } }, // 不过你可以提供一个自定义的 `arrayOf` 或 `objectOf` // 验证器，它应该在验证失败时返回一个 Error 对象。 它被用 // 于验证数组或对象的每个值。验证器前两个参数的第一个是数组 // 或对象本身，第二个是它们对应的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) { if (!/matchme/.test(propValue[key])) { return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); } }) }; React V16.7.0-alpha Hooks Rules of Hooks 只能在顶层调用Hooks 。不要在循环，条件或嵌套函数中调用Hook 只能在functional component中使用 虚拟 DOM 和 DOM Diff 虚拟DOM 用 JS 去按照 DOM 结构来实现的树形结构对象，你也可以叫做 DOM 对象 实现一下虚拟DOM // element.js // 虚拟DOM元素的类，构建实例对象，用来描述DOM class Element { constructor(type, props, children) { this.type = type; this.props = props; this.children = children; } } // 创建虚拟DOM，返回虚拟节点(object) function createElement(type, props, children) { return new Element(type, props, children); } export { Element, createElement } 参数分析： type: 指定元素的标签类型，如'li', 'div', 'a'等 props: 表示指定元素身上的属性，如class, style, 自定义属性等 children: 表示指定元素是否有子节点，参数以数组的形式传入 渲染虚拟DOM // element.js class Element { // 省略 } function createElement() { // 省略 } // render方法可以将虚拟DOM转化成真实DOM function render(domObj) { // 根据type类型来创建对应的元素 let el = document.createElement(domObj.type); // 再去遍历props属性对象，然后给创建的元素el设置属性 for (let key in domObj.props) { // 设置属性的方法 setAttr(el, key, domObj.props[key]); } // 遍历子节点 // 如果是虚拟DOM，就继续递归渲染 // 不是就代表是文本节点，直接创建 domObj.children.forEach(child => { child = (child instanceof Element) ? render(child) : document.createTextNode(child); // 添加到对应元素内 el.appendChild(child); }); return el; } // 设置属性 function setAttr(node, key, value) { switch(key) { case 'value': // node是一个input或者textarea就直接设置其value即可 if (node.tagName.toLowerCase() === 'input' || node.tagName.toLowerCase() === 'textarea') { node.value = value; } else { node.setAttribute(key, value); } break; case 'style': // 直接赋值行内样式 node.style.cssText = value; break; default: node.setAttribute(key, value); break; } } // 将元素插入到页面内 function renderDom(el, target) { target.appendChild(el); } export { Element, createElement, render, setAttr, renderDom }; DOM-diff闪亮登场 说到DOM-diff那一定要清楚其存在的意义，给定任意两棵树，采用先序深度优先遍历的算法找到最少的转换步骤 作用： 根据两个虚拟对象创建出补丁，描述改变的内容，将这个补丁用来更新DOM // diff.js function diff(oldTree, newTree) { // 声明变量patches用来存放补丁的对象 let patches = {}; // 第一次比较应该是树的第0个索引 let index = 0; // 递归树 比较后的结果放到补丁里 walk(oldTree, newTree, index, patches); return patches; } function walk(oldNode, newNode, index, patches) { // 每个元素都有一个补丁 let current = []; if (!newNode) { // rule1 current.push({ type: 'REMOVE', index }); } else if (isString(oldNode) && isString(newNode)) { // 判断文本是否一致 if (oldNode !== newNode) { current.push({ type: 'TEXT', text: newNode }); } } else if (oldNode.type === newNode.type) { // 比较属性是否有更改 let attr = diffAttr(oldNode.props, newNode.props); if (Object.keys(attr).length > 0) { current.push({ type: 'ATTR', attr }); } // 如果有子节点，遍历子节点 diffChildren(oldNode.children, newNode.children, patches); } else { // 说明节点被替换了 current.push({ type: 'REPLACE', newNode}); } // 当前元素确实有补丁存在 if (current.length) { // 将元素和补丁对应起来，放到大补丁包中 patches[index] = current; } } function isString(obj) { return typeof obj === 'string'; } function diffAttr(oldAttrs, newAttrs) { let patch = {}; // 判断老的属性中和新的属性的关系 for (let key in oldAttrs) { if (oldAttrs[key] !== newAttrs[key]) { patch[key] = newAttrs[key]; // 有可能还是undefined } } for (let key in newAttrs) { // 老节点没有新节点的属性 if (!oldAttrs.hasOwnProperty(key)) { patch[key] = newAttrs[key]; } } return patch; } // 所有都基于一个序号来实现 let num = 0; function diffChildren(oldChildren, newChildren, patches) { // 比较老的第一个和新的第一个 oldChildren.forEach((child, index) => { walk(child, newChildren[index], ++num, patches); }); } // 默认导出 export default diff; 比较规则 新的DOM节点不存在{type: 'REMOVE', index} 文本的变化{type: 'TEXT', text: 1} 当节点类型相同时，去看一下属性是否相同，产生一个属性的补丁包{type: 'ATTR', attr: {class: 'list-group'}} 节点类型不相同，直接采用替换模式{type: 'REPLACE', newNode} patch补丁更新 import { Element, render, setAttr } from './element'; let allPatches; let index = 0; // 默认哪个需要打补丁 function patch(node, patches) { allPatches = patches; // 给某个元素打补丁 walk(node); } function walk(node) { let current = allPatches[index++]; let childNodes = node.childNodes; // 先序深度，继续遍历递归子节点 childNodes.forEach(child => walk(child)); if (current) { doPatch(node, current); // 打上补丁 } } function doPatch(node, patches) { // 遍历所有打过的补丁 patches.forEach(patch => { switch (patch.type) { case 'ATTR': for (let key in patch.attr) { let value = patch.attr[key]; if (value) { setAttr(node, key, value); } else { node.removeAttribute(key); } } break; case 'TEXT': node.textContent = patch.text; break; case 'REPLACE': let newNode = patch.newNode; newNode = (newNode instanceof Element) ? render(newNode) : document.createTextNode(newNode); node.parentNode.replaceChild(newNode, node); break; case 'REMOVE': node.parentNode.removeChild(node); break; default: break; } }); } export default patch; patch做了什么？ 用一个变量来得到传递过来的所有补丁allPatches patch方法接收两个参数(node, patches) 在方法内部调用walk方法，给某个元素打上补丁 walk方法里获取所有的子节点 给子节点也进行先序深度优先遍历，递归walk 如果当前的补丁是存在的，那么就对其打补丁(doPatch) doPatch打补丁方法会根据传递的patches进行遍历 判断补丁的类型来进行不同的操作: 属性ATTR for in去遍历attrs对象，当前的key值如果存在，就直接设置属性setAttr； 如果不存在对应的key值那就直接删除这个key键的属性 文字TEXT 直接将补丁的text赋值给node节点的textContent即可 替换REPLACE 新节点替换老节点，需要先判断新节点是不是Element的实例，是的话调用render方法渲染新节点；不是的话就表明新节点是个文本节点，直接创建一个文本节点就OK了。之后再通过调用父级parentNode的replaceChild方法替换为新的节点 删除REMOVE 直接调用父级的removeChild方法删除该节点 package mirrorx 参考文献 让虚拟DOM和DOM-diff不再成为你的绊脚石 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-vue.html":{"url":"src/js-vue.html","title":"Vue","keywords":"","body":"Vue powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-omi.html":{"url":"src/js-omi.html","title":"Omi","keywords":"","body":"Omi 全面拥抱 Web Components powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-mvvm.html":{"url":"src/js-mvvm.html","title":"MVVM","keywords":"","body":"MVVM MVVM框架理解 MVC 将整个前端页面分成View，Controller，Modal，视图上发生变化，通过Controller（控件）将响应传入到Model（数据源），由数据源改变View上面的数据整个过程看起来是行云流水，业务逻辑放在Model当中，页面渲染逻辑放在View当中，但在实际运用上却存在一个问题：那就是MVC框架允许View和Model直接进行通信！！背离了开发所应该遵循的“开放封闭原则” 面对这个问题，MVVM框架就出现了，它与MVC框架的主要区别有两点： 实现数据与视图的分离 通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了 可以看到MVVM分别指View，Model，View-Model，View通过View-Model的DOM Listeners将事件绑定到Model上，而Model则通过Data Bindings来管理View中的数据，View-Model从中起到一个连接桥的作用 MVVM的实现原理 MVVM的实现主要是三个核心点： 响应式：vue如何监听data的属性变化 模板解析：vue的模板是如何被解析的 渲染：vue模板是如何被渲染成HTML的 响应式 Object.defineProperty var vm = {} var data = { name: 'zhangsan', age: 20 } var key, value for (key in data) { (function (key) { Object.defineProperty(vm, key, { get: function () { console.log('get', data[key]) // 监听 return data[key] }, set: function (newVal) { console.log('set', newVal) // 监听 data[key] = newVal } }) })(key) } 模板解析 首先模板是什么？ 模板本质上是一串字符串，它看起来和html的格式很相像，实际上有很大的区别，因为模板本身还带有逻辑运算，比如v-if，v-for等等，但它最后还是要转换为html来显示模板在vue中必须转换为JS代码，原因在于：在前端环境下，只有JS才是一个图灵完备语言，才能实现逻辑运算，以及渲染为html页面 render render函数中的核心就是with函数 with函数将某个对象添加到作用域链的顶部，如果在 statement中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值 var obj = { name: 'zhangsan', age: 20, getAddress: function () { alert('beijing') } } function fn1() { with(obj) { alert(age) alert(name) getAddress() } } fn1() 而在render函数中，with的用法是这样: submit {{item}} // 对应的js文件 var data = { title: '', list: [] } // 初始化 Vue 实例 var vm = new Vue({ el: '#app', data: data, methods: { add: function () { this.list.push(this.title) this.title = '' } } }) with(this){ // this 就是 vm return _c( 'div', { attrs:{\"id\":\"app\"} }, [ _c( 'div', [ _c( 'input', { directives:[ { name:\"model\", rawName:\"v-model\", value:(title), expression:\"title\" } ], domProps:{ \"value\":(title) }, on:{ \"input\":function($event){ if($event.target.composing)return; title=$event.target.value } } } ), _v(\" \"), _c( 'button', { on:{ \"click\":add } }, [_v(\"submit\")] ) ] ), _v(\" \"), _c('div', [ _c( 'ul', _l((list),function(item){return _c('li',[_v(_s(item))])}) ) ] ) ] ) } 在一开始，因为new操作符，所以this指向了vm，通过with我们将vm这个对象放在作用域链的顶部，因为在函数内部我们会多次调用vm内部的属性，所以使用with可以缩短变量长度，提供系统运行效率。 _c函数表示的是创建一个新的html元素, _v函数表示创建一个文本节点，_l函数表示创建一个数组 最终render函数返回的是一个虚拟DOM. 如何将模板渲染为html 模板渲染为html分为两种情况：第一种是初次渲染的时候第二种是渲染之后数据发生改变的时候，它们都需要调用updateComponent, vm._update(vnode){ const prevVnode = vm._vnode vm._vnode = vnode if (!prevVnode){ vm.$el = vm.__patch__(vm.$el,vnode) } else { vm.$el = vm.__patch__(prevVnode,vnode) } } function updateComponent(){ vm._update(vm._render()) } 首先读取当前的虚拟DOM——vm._vnode,判断其是否为空，若为空，则为初次渲染，将虚拟DOM全部渲染到所对应的容器当中（vm.$el），若不为空，则是数据发生了修改，通过响应式我们可以监听到这一情况，使用diff算法完成新旧对比并修改 reference MVVM框架理解及其原理实现 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-baidu-minipro.html":{"url":"src/js-baidu-minipro.html","title":"百度小程序","keywords":"","body":"百度小程序 整体框架 百度小程序的开发api，架构设计和微信小程序基本一致 为了提升整体性能，充分利用手机的多CPU性能： 把逻辑层与渲染层分离，分别位于不同的运行容器 异步请求都由native来执行 逻辑层 逻辑层就是对开发者所暴露的api，有APP， Page，布局文件，其中的App。Page都是两个函数 App()函数的处理： 直接创建App对象，全局唯一对象 Page()函数的处理： 保存到Map中，不会马上构建Page对象，当导航到页面时，才会真正创建Page对象 渲染层 使用MVVM框架san来渲染界面 在编译期间把小程序标签转化为san框架所支持的标签 为每个小程序页面，创建对应的san框架下Page组件，PageComponent的template就是swan.xml转译后的内容 渲染层与逻辑层交互 渲染层接收用户的交互事件，由统一的函数处理后，通过消息总线传递到逻辑层的Page对象，再调用对应的函数 逻辑层依据用户操作，执行业务操作，修改data数据，通过消息总线传递到渲染层的组件里，San.Page组件会自动更新界面 开发流程 编译 目录结构 app.js的源码App({ onLaunch(event) { console.log('onLaunch'); }, onShow(event) { console.log('onShow'); }, globalData: { userInfo: 'user' } }); index.js的源码var p = []; Page({ data: { text: \"这是一段文字.\" }, add: function(e) { p.push(\"其他文字\"); this.setData({ text: \"这是一段文字.\" + p.join(\",\") }) }, remove: function(e) { if(p.length > 0){ p.pop(); this.setData({ text: \"这是一段文字.\" + p.join(\",\") }); } } }); index.swan的源码 add text remove text 编译之后 目录结构 app.js的源码window.define(\"138\", function(t, e, n, o, a, i, s, c, r, u, d, l, g, w, f, h) { var p = []; Page({ data: { text: \"这是一段文字.\" }, add: function(t) { p.push(\"其他文字\"); this.setData({ text: \"这是一段文字.\" + p.join(\",\") }) }, remove: function(t) { p.length > 0 && (p.pop(), this.setData({ text: \"这是一段文字.\" + p.join(\",\") })) } }) }); window.define(\"193\", function(t, e, n, o, a, i, s, c, r, u, d, l, g, w, f, h) { App({ onLaunch: function(t) { console.log(\"Lifecycle App onLaunch\") }, onShow: function(t) { console.log(\"Lifecycle App onShow\") }, globalData: { userInfo: 'user' } }) }); window.__swanRoute = \"app\"; window.usingComponents = []; require(\"193\"); window.__swanRoute = \"pages/text/text\"; window.usingComponents = []; require(\"138\"); index.swan.js的源码// 注意，做了一些简化 ((global)=>{ global.errorMsg = []; var templateComponents = Object.assign({}, {}); var param = {}; var filterArr = JSON.parse(\"[]\"); try { filterArr && filterArr.forEach(function (item) { param[item.module] = eval(item.module) }); var pageContent = ` add text remove text `; var renderPage = function (filters, modules) { // 路径与该组件映射 // var customAbsolutePathMap = (global.componentFactory.getAllComponents(), {}); // 当前页面使用的自定义组件 // const pageUsingComponentMap = JSON.parse(\"{}\"); // 生成该页面引用的自定义组件 // const customComponents = Object.keys(pageUsingComponentMap).reduce((customComponents, customName) => { // customComponents[customName] = customAbsolutePathMap[pageUsingComponentMap[customName]]; // return customComponents; // }, {}); global.pageRender(pageContent, templateComponents) }; renderPage(filterArr, param); } catch (e) { global.errorMsg['execError'] = e; throw e; } })(window); 编译总结： 对template进行转换： 标签转换：bind:tap ===> on-bindtap 事件包装：eventHappen(‘tap’, $event, ‘add’, ‘’, ‘bind’) 对App.js进行包装，提升效率，减少逐一加载流程 通过渲染模板，生成index.swan.js文件，提升渲染效率 加载、启动、渲染 用户点击跳转到小程序后： Native的任务： 下载小程序.zip文件 启动两个web运行容器： 渲染层webview加载slaves.html 逻辑层jscore加载master.html 解析小程序app.json，发送’AppReady’事件 逻辑层master.js 监听’AppReady’事件，执行小程序的调起逻辑 ```javascript /** 监听客户端的调起逻辑 */ listenAppReady() { this.swaninterface.bind('AppReady', event => { console.log('master listener AppReady ', event); swanEvents('masterActiveStart'); // 给三方用的，并非给框架用，请保留 this.context.appConfig = event.appConfig; // 初始化master的入口逻辑 this.initRender(event); // this.preLoadSubPackage(); }); } - 初始化master的入口逻辑，小程序的每个界面，对应一个Slave对象（与渲染层的slave.js不一样），依据用户打开多个页面，构建一个导航栈，保存在navigator对象里 ```javascript /** * 初始化渲染 * * @param {Object} initEvent - 客户端传递的初始化事件对象 * @param {string} initEvent.appConfig - 客户端将app.json的内容（json字符串）给前端用于处理 * @param {string} initEvent.appPath - app在手机上的磁盘位置 * @param {string} initEvent.wvID - 第一个slave的id * @param {string} initEvent.pageUrl - 第一个slave的url */ initRender(initEvent) { // 设置appConfig this.navigator.setAppConfig({ ...JSON.parse(initEvent.appConfig), ...{ appRootPath: initEvent.appPath } }); swanEvents('masterActiveInitRender'); // 压入initSlave this.navigator.pushInitSlave({ pageUrl: initEvent.pageUrl, slaveId: +initEvent.wvID, root: initEvent.root, preventAppLoad: initEvent.preventAppLoad }); this.appPath = initEvent.appPath; swanEvents('masterActivePushInitslave'); } 创建初始化页面的slave后，如果没有预加载，就加载小程序里的app.js文件（注意：是编译后的app.js文件），并发送’slaveLoaded’事件，通知渲染层开始渲染 ```javascript /** 初始化第一个slave @param {Object} [initParams] - 初始化的参数 */ pushInitSlave(initParams) { .... // 创建初始化slave this.initSlave = this.createInitSlave(initParams.pageUrl, this.appConfig); // slave的init调用 this.initSlave.init(initParams) .then(initRes => { swanEvents('masterActiveCreateInitslaveEnd'); // 入栈 this.history.pushHistory(this.initSlave); swanEvents('masterActivePushInitslaveEnd'); // 调用slave的onEnqueue生命周期函数 this.initSlave.onEnqueue(); swanEvents('masterActiveOnqueueInitslave'); }); } /** 初始化为第一个页面 * @param {Object} initParams 初始化的配置参数 @return {Promise} 返回初始化之后的Promise流 */ Slave.init(initParams) { this.isFirstPage = true; return Promise .resolve(initParams) .then(initParams => { swanEvents('masterActiveInitAction'); if (!!initParams.preventAppLoad) { return initParams; } // const loadCommonJs = this.appConfig.splitAppJs // && !this.appConfig.subPackages // ? 'common.js' : 'app.js'; const loadCommonJs = 'app.js'; return loader .loadjs(`${this.appRootPath}/${loadCommonJs}`, 'masterActiveAppJsLoaded') .then(() => { return this.loadJs.call(this, initParams); }); }) .then(initParams => { this.uri = initParams.pageUrl.split('?')[0]; this.accessUri = initParams.pageUrl; this.slaveId = initParams.slaveId; // init的事件为客户端处理，确保是在slave加载完成之后，所以可以直接派发 this.swaninterface.communicator.fireMessage({ type: `slaveLoaded${this.slaveId}`, message: {slaveId: this.slaveId} }); return initParams; }); } ``` 执行slave入栈后的生命周期函数this.initSlave.onEnqueue(); 在此函数里，会真正Page Instance，同时监听到渲染层准备好后，发送’initData’事件 ```javascript /** 入栈之后的生命周期方法 * @return {Object} 入栈之后，创建的本slave的页面实例对象 / onEnqueue() { return this.createPageInstance(); } /* 创建页面实例，并且，当slave加载完成之后，向slave传递初始化data * @return {Promise} 创建完成的事件流 */ createPageInstance() { if (this.isCreated()) {return Promise.resolve(); } swanEvents('masterActiveCreatePageFlowStart', {uri: this.uri }); const userPageInstance = createPageInstance(this.accessUri, this.slaveId, this.appConfig); const query = userPageInstance.privateProperties.accessUri.split('?')[1]; this.setUserPageInstance(userPageInstance); try {swanEvents('masterPageOnLoadHookStart'); userPageInstance._onLoad(getParams(query)); swanEvents('masterPageOnLoadHookEnd'); } catch (e) {// avoid empty state } this.status = STATUS_MAP.CREATED; console.log(Master 监听 slaveLoaded 事件，slaveId=${this.slaveId}); return this.swaninterface.invoke('loadJs', {uri: this.uri, eventObj: { wvID: this.slaveId }, success: params => { swanEvents('masterActiveCreatePageFlowEnd'); swanEvents('masterActiveSendInitdataStart'); userPageInstance.privateMethod .sendInitData.call(userPageInstance, this.appConfig); swanEvents('masterActiveSendInitdataEnd'); } }); } ``` 渲染层slave.js 监听’PageReady’事件，加载对应页面的文件：app.css，index.css，index.swan.js文件 ```javascript /** 监听pageReady，触发整个入口的调起 @param {Object} [global] 全局对象 */ listenPageReady(global) { swanEvents('slavePreloadListened'); // 控制是否开启预取initData的开关 let advancedInitDataSwitch = false; this.swaninterface.bind('PageReady', event => { swanEvents('slaveActiveStart', { pageInitRenderStart: Date.now() + '' }); ... const appPath = event.appPath; const pagePath = event.pagePath.split('?')[0]; const onReachBottomDistance = event.onReachBottomDistance; ... let loadUserRes = () => { // 设置页面的基础路径为当前页面本应所在的路径 // 行内样式等使用相对路径变成此值 // setPageBasePath(`${appPath}/${pagePath}`); swanEvents('slaveActivePageLoadStart'); // 加载用户的资源 Promise.all([ loader.loadcss(`${appPath}/app.css`, 'slaveActiveAppCssLoaded'), loader.loadcss(`${appPath}/${pagePath}.css`, 'slaveActivePageCssLoaded') ]) .catch(() => { console.warn('加载css资源出现问题，请检查css文件'); }) .then(() => { // todo: 兼容天幕，第一个等天幕同步后，干掉 swanEvents('slaveActiveCssLoaded'); swanEvents('slaveActiveSwanJsStart'); loader.loadjs(`${appPath}/${pagePath}.swan.js`, 'slaveActiveSwanJsLoaded'); }); }; // (event.devhook === 'true' ? loadHook().then(loadUserRes).catch(loadUserRes) : loadUserRes()); loadUserRes(); }); } ``` 在每个页面编译后的xxx.swan.js文件里，会执行pageRender()函数，进行界面渲染，如此demo里的index.swan.js文件((global)=>{ global.errorMsg = []; var templateComponents = Object.assign({}, {}); var param = {}; var filterArr = JSON.parse(\"[]\"); try { filterArr && filterArr.forEach(function (item) { param[item.module] = eval(item.module) }); var pageContent = ` add text remove text `; var renderPage = function (filters, modules) { ... global.pageRender(pageContent, templateComponents) }; renderPage(filterArr, param); } catch (e) { global.errorMsg['execError'] = e; throw e; } })(window); global.pageRender()函数是在slave.js文件里定义的方法，其内部的逻辑就是创建对应的san框架里的Page组件，等待初始化数据过来后，再绑定到界面上 ```javascript /** 注册所有components(也包括顶层components -- page) */ registerComponents() { ... global.pageRender = (pageTemplate, templateComponents, customComponents, filters, modules) => { ... // 定义当前页面的组件 componentFactory.componentDefine( 'page', { template: `${pageTemplate}`, superComponent: 'super-page' }, { classProperties: { components: {...componentFactory.getComponents(), ...templateComponents, ...customComponents}, filters: { ...filtersObj } } } ); swanEvents('slaveActiveDefineComponentPage'); // 获取page的组件类 const Page = global.componentFactory.getComponents('page'); // 初始化页面对象 const page = new Page(); swanEvents('slaveActiveConstructUserPage'); // 调用页面对象的加载完成通知 page.slaveLoaded(); swanEvents('slaveActiveUserPageSlaveloaded'); // 用于记录用户模板代码在开始执行到监听initData事件之前的耗时 global.FeSlaveSwanJsInitEnd = Date.now(); // 监听等待initData，进行渲染 page.communicator.onMessage('initData', params => { swanEvents('slaveActiveReceiveInitData'); try { // 根据master传递的data，设定初始数据，并进行渲染 page.setInitData(params); swanEvents('slaveActiveRenderStart'); // 真正的页面渲染，发生在initData之后 // 此处让页面真正挂载处于自定义组件成功引用其他自定义组件之后, // 引用其它自定义组件是在同一时序promise.resolve().then里执行, 故此处attach时, 自定义组件已引用完成 setTimeout(() => { page.attach(document.body); // 通知master加载首屏之后的逻辑 page.communicator.sendMessage( 'master', { type: 'slaveAttached', slaveId: page.slaveId } ); swanEvents('slaveActivePageAttached'); }, 0); } catch (e) { console.log(e); global.errorMsg['renderError'] = e; } }, {listenPreviousEvent: true}); ... }; ... } ``` 当界面渲染后，发送’slaveAttached’事件，逻辑层执行onShow()生命周期函数 reference 百度小程序源码解读 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-ast.html":{"url":"src/js-ast.html","title":"AST抽象语法树","keywords":"","body":"AST抽象语法树 package const esprima = require('esprima'); const estraverse = require('estraverse'); const escodegen = require('escodegen'); reference AST抽象语法树 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-sw-start.html":{"url":"src/js-sw-start.html","title":"ServiceWorker","keywords":"","body":"Service Worker native app 可以做到离线使用、消息推送、后台自动更新，service worker 的出现正是为了使得 web app 也可以具有类似的能力。 Service Worker 可以： 后台消息传递 网络代理，转发请求，伪造响应 离线缓存 消息推送 ... 生命周期 一个 service worker 要经历以下历程： 安装 激活，激活成功之后，打开chrome://inspect/#service-workers 可以查看当前运行的 service worker 监听 fetch 和 message 事件，下面两种事件会进行简要描述 销毁，是否销毁有浏览器决定，如果一个 service worker 长期不使用或者机器内存有限，则可能会销毁 worker fetch 事件 在页面发起 http 请求时， service worker 可以通过 fetch 事件拦截请求，并且给出自己的响应。 W3C提供了一个新的 fetch api，用于取代 XMLHttpRequest ，与XMLHttpRequest 最大的不同有两点： fetch() 方法返回的是 Promise 对象，通过then 方法进行连续调用，减少嵌套。 ES6 的 Promise 在成为标准之后，会越来越方便开发人员。 提供了 Request、Response 对象，如果做过后端开发，对 Request 、Response 应该比较熟悉。前端要发起请求可以通过 url 发起，也可以使用 Request 对象发起，而且 Request 可以复用。但是 Response 用在哪里呢？在service worker 出现之前，前端确实不会自己给自己发消息，但是有了 service worker，就可以在拦截请求之后根据需要返回自己的响应，对页面而言，这个普通的请求结果并没有区别，这是 Response 的一处应用。 /* 由于是get请求，直接把参数作为query string传递了 */ var URL = 'https://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=your_api_key&format=json&nojsoncallback=1&tags=penguins'; function fetchDemo() { // fetch(url, option)支持两个参数，option中可以设置header、body、method信息 fetch(URL).then(function(response) { // 通过promise 对象获得相应内容，并且将响应内容按照json格式转成对象，json()方法调用之后返回的依然是promise对象 // 也可以把内容转化成arraybuffer、blob对象 return response.json(); }).then(function(json) { // 渲染页面 insertPhotos(json); }); } fetchDemo(); fetch api 与 XMLHttpRequest 相比，更加简洁，并且提供的功能更全面，资源获取方式比ajax更优雅。兼容性方面：chrome 42开始支持，对于旧浏览器，可以通过官方维护的polyfill支持。 message 事件 页面和 service worker 之间可以通过posetMessage() 方法发送消息，发送的消息可以通过 message事件接收到。 这是一个双向的过程，页面可以发消息给service worker，service worker也可以发送消息给页面，由于这个特性，可以将service worker作为中间纽带，使得一个域名或者子域名下的多个页面可以自由通信。 这里是一个小的页面之间通信demo 问题1. 运行时间 service worker并不是一直在后台运行的。在页面关闭后，浏览器可以继续保持service worker运行，也可以关闭service worker，这取决与浏览器自己的行为。所以不要定义一些全局变量， var hitCounter = 0; this.addEventListener('fetch', function(event) { hitCounter++; event.respondWith( new Response('Hit number ' + hitCounter) ); }); 返回的结果可能是没有规律的：1,2,1,2,1,1,2….，原因是hitCounter并没有一直存在，如果浏览器关闭了它，下次启动的时候hitCounter就赋值为0了 这样的事情导致调试代码困难，当你更新一个service worker以后，只有在打开新页面以后才可能使用新的service worker，在调试过程中经常等上一两分钟才会使用新的，比较抓狂。 问题2. 权限太大 当service worker监听fetch事件以后，对应的请求都会经过service worker。通过chrome的network工具，可以看到此类请求会标注：from service worker。如果service worker中出现了问题，会导致所有请求失败，包括普通的html文件。所以service worker的代码质量、容错性一定要很好才能保证web app正常运行。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/js-ws.html":{"url":"src/js-ws.html","title":"WebSocket","keywords":"","body":"WebSocket WebSocket 协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工（full-duplex）通信——允许服务其主动发送信息给客户端。 概述 The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or s and long polling). WebSocket 协议支持（在受控环境中公运行不受信任的代码的）客户端与（选者加入该代码的通信的）远程主机之间进行全双工通信。用于此的安全模型是Web浏览器常用的基于原始的安全模式。协议包括一个开放的握手以及随后的TCP层上的消息帧。该技术的目标是为基于浏览器的、需要和服务器进行双向通信的（服务器不能依赖于打开多个HTTP链接（例如，使用 XMLHttpRequest 或和长轮询））应用程序提供一种通信机制。 产生背景 简单的说，WebSocket协议之前，双工通信是通过多个http链接来实现的，这导致了效率低下。WebSocket解决了这个问题。 下面是标准RFC6455中的产生背景概述。 长久以来，创建实现客户端和用户端之间双工通讯的web app 都会造成HTTP轮询的滥用：客户端向主机不断发送不同的HTTP呼叫来进行询问。 这会导致一系列问题： 服务器被迫为每个客户端使用许多不同的底层TCP连接：一个用于向客户端发送信息，其它用于接收每个传入消息。 有线协议有很高的开销，每个客户端和服务器之间都有HTTP头。 客户端脚本被迫维护从传出连接到传入连接的映射来追踪回复。 一个更简单的解决方案是使用单个TCP连接双向通信。这就是WebSocket协议所提供的功能。结合WebSocket API，WebSocket协议提供了一个用来替代HTTP轮询实现网页到远程主机的双向通信的方法。 WebSocket协议被设计来取代用HTTP作为传输层的双向通讯技术，这些技术只能牺牲效率和可依赖性其中一方来提高另一方，因为HTTP最初的目的不是为了双向通讯。 实现原理 在实现websocket连线过程中，需要通过浏览器发出websocket连线请求，然后服务器发出回应，这个过程通常称为‘握手’。在WebSocket API，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一个快速通道。两者之间就直接可以数据互相传送。在此WebSocket协议中，为我们实现及时服务带来了两大好处： Header互相沟通的Header是很小的-大概只有2Bytes Server Push服务器的推送，服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。 握手协议例子 浏览器请求 GET /webfin/websocket/ HTTP/1.1 Host: localhostUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==Origin: http://服务器地址Sec-WebSocket-Version: 13 服务器回应 HTTP/1.1 101 Switching Protocols Upgrade: websocketConnection: UpgradeSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8= HTML5 Web Socket API 在HTML5中内置有一些API，用于响应应用程序发起的请求。基本API语句如下： var ws = new WebSocket(url, name); //url为WebSocket服务器的地址，name 为发起握手协议的名称，为可选择项 ws.send(); ws.onmessage = (function () {...})(); ws.onerror = (function () {...})(); ws.close(); 浏览器以及语言支持 所有浏览器都支持RFC6455。但是具体的WebSocket版本有区别。php jetty netty ruby Kaazing nginx python Tomcat Django erlang netty .net等语言均可以用来实现支持WebSocket的服务器。 websocket api在浏览器端的广泛实现似乎只是一个时间问题了, 值得注意的是服务器端没有标准的api, 各个实现都有自己的一套api, 并且tcp也没有类似的提案, 所以使用websocket开发服务器端有一定的风险.可能会被锁定在某个平台上或者将来被迫升级。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node.html":{"url":"src/node.html","title":"NodeJS","keywords":"","body":"NodeJS powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-assert.html":{"url":"src/node-assert.html","title":"Assert 断言","keywords":"","body":"Node assert 断言 assert 模块提供了断言测试的函数，用于测试不变式。 assert(value[,message])assert.ok()的别名。 assert.deepEqual(actual, expected[, message])测试 actual 参数与 expected 参数是否深度相等。原始值使用相等运算符 (==) 比较。 只测试可枚举的自身属性，不测试对象的原型、连接符、或不可枚举的属性(这些情况使用 assert.deepStrictEqual())。 // 不会跑出 AssertionError，因为 RegExp 对象的属性不是可枚举的 assert.deepEqual(/a/gi, new Date()); Map 和 Set 包含的自相也会被测试。 子对象中可枚举的自身属性也会被测试： const assert = require('assert'); const obj1 = { a: { b: 1 } }; const obj2 = { a: { b: 2 } }; const obj3 = { a: { b: 1 } }; const obj4 = Object.create(obj1); assert.deepEqual(obj1, obj1); // 测试通过，对象与自身相等。 assert.deepEqual(obj1, obj2); // 抛出 AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } } // 因为 b 属性的值不同。 assert.deepEqual(obj1, obj3); // 测试通过，两个对象相等。 assert.deepEqual(obj1, obj4); // 抛出 AssertionError: { a: { b: 1 } } deepEqual {} // 因为不测试原型。 如果两个值不相等，则抛出一个带有 message 属性的 AssertionError，其中 message 属性的值等于传入的 message 参数的值。 如果 message 参数为 undefined，则赋予默认的错误信息。 assert.deepStrictEqual(actual, expected[, message]) 与 assert.deepEqual() 大致相同，但是有一些区别： 原始值使用 全等运算符（===）比较。 Set 的值与 Map 的键使用 SameValueZero 比较。 对象的原型也是用全等运算符 比较 对象的类型标签要求相同 Object wrappers are compared both as objects and unwrapped values. const assert = require('assert'); assert.deepEqual({ a: 1 }, { a: '1' }); // 测试通过，因为 1 == '1'。 assert.deepStrictEqual({ a: 1 }, { a: '1' }); // 抛出 AssertionError: { a: 1 } deepStrictEqual { a: '1' } // 因为使用全等运算符 1 !== '1'。 // 以下对象都没有自身属性。 const date = new Date(); const object = {}; const fakeDate = {}; Object.setPrototypeOf(fakeDate, Date.prototype); assert.deepEqual(object, fakeDate); // 测试通过，不测试原型。 assert.deepStrictEqual(object, fakeDate); // 抛出 AssertionError: {} deepStrictEqual Date {} // 因为原型不同。 assert.deepEqual(date, fakeDate); // 测试通过，不测试类型标签。 assert.deepStrictEqual(date, fakeDate); // 抛出 AssertionError: 2017-03-11T14:25:31.849Z deepStrictEqual Date {} // 因为类型标签不同。 assert.deepStrictEqual(new Number(1), new Number(2)); // Fails because the wrapped number is unwrapped and compared as well. assert.deepStrictEqual(new String('foo'), Object('foo')); // OK because the object and the string are identical when unwrapped. 如果两个值不相等，则抛出一个带有 message 属性的 AssertionError，其中 message 属性的值等于传入的 message 参数的值。 如果 message 参数为 undefined，则赋予默认的错误信息。 assert.doesNotThrow(block[, error][, message]) 断言 block 函数不会抛出错误。当 assert.doesNotThrow() 被调用时，他会立即调用 block 函数。如果抛出错误且错误类型与 error 参数指定的相同，则抛出 AssertionError。 如果错误类型不相同，或 error 参数为 undefined， 则抛出错误。 assert.fail(actual, expected[, message[, operator[,stackStartFunction]]]) 抛出 AssertionError assert.ifError(value)如果 value 为真，则抛出 value。 可用于测试回调函数的 error 参数 assert.notDeepEqual(actual, expected[, message]) assert.ok(value[, message]) assert.throws(block[, error][, message])断言 block 函数会抛出错误 注意事项 对于 SameValueZero 比较， 建议使用 ES2015 的 Object.is(); powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-chai.html":{"url":"src/node-chai.html","title":"chai.js 断言库","keywords":"","body":"chai.js 断言库 BDD风格的expect/should API，TDD 风格的Assert API BDD expect 和 should 是 BDD 风格的，二者使用相同的链式语言来组织断言，但不同于他们初始化断言的方式：expect 使用构造函数来创建断言对象实例，而should通过为Object.protorype新增方法来实现断言（所以should 不支持 IE）；expect 直接指向 chai.expect ,而 should 则是chai.should(). 语言链 to be been is that which and has have with at of same .not 对之后的断言取反 expect(foo).to.not.equal('bar'); expect(goodFn).to.not.throw(Error); expect({ foo: 'baz' }).to.have.property('foo').and.not.equal('bar'); .deep powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-global.html":{"url":"src/node-global.html","title":"Node Global Obj And Var","keywords":"","body":"NODEJS Node.js 的全局对象和全局变量 全局对象 global: 表示 Node 所在的全局环境，类似于浏览器中的 window 对象。 process: 指向 Node 内置的 process模块，允许开发者与当前进程互动。(process.exit()); console: 指向 Node 内置的 console 模块，提供命令行环境中的标准、标准输出环境。(console.log()) 全局函数 定时器函数: setTimeout(), clearTimeout(), setInterval(), clearInterval(). require: 用于加载模块。 全局变量 __filename: 指向当前运行的脚本文件名。 __dirname: 指向当前运行的脚本所在的目录。 准全局变量 模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为 module, module.exports , exports 等。 module 变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 module.id 模块的识别符，通常是模块的文件名。 module.filename 模块的文件名。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回使用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 这里需要特别指出的是，exports变量实际上是一个指向 module.exports 对象的链接，等同在每个模块头部，有一行这样的命令。 var exports = module.exports; 这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数： exports = function (x){ console.log(x);}; 上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。但是，下面这样写是可以的。 exports.area = function (r) { return Math.PI * r * r; }; exports.circumference = function (r) { return 2 * Math.PI * r; }; powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-CLI.html":{"url":"src/node-CLI.html","title":"CLI Writed By Nodejs","keywords":"","body":"Node.js 编写CLI Node.js 的应用场景有前后端分离、海量web页面渲染服务、命令行工具和桌面端应用等等。 Why Node.js npm OS 无关的包管理机制 npm 完善的生态系统 对JavaScript 更加熟悉 npm关联CLI的基本原理 在package.json里面增加一个bin字段。模块发布到npm上后，开发者安装这个包的时候会检查是否有bin字段，如果有bin字段则会使用软链接的方式创建可以全局使用的命令。 如果模块采用全局安装的方式，对于类unix系统，会在/usr/local/bin目录创建软链接，对于windows系统，在`C:\\Users\\username\\AppData\\Roaming\\npm目录创建软链接。 如果模块采用局部安装的方式，则会在项目内的./node_modules/.bin目录创建软链接。配置好的package.json如下: \"description\": \"A command line tool aims to improve front-end engineer workflow.\", \"main\": \"lib/index.js\", \"bin\" : { \"feflow\" : \"./bin/feflow\" } Feflow的技术架构 Feflow总体分为3个模块，包括parser命令行参数解析、核心命令以及插件机制。【链接】 扫描器的实现 插件机制设计 feflow install #安装一个插件，--force则会强制安装 feflow remove #卸载一个插件 feflow list #列举所有插件信息 feflow list #列举某个插件信息 插件机制实现 插件机制的实现包括两个部分：插件注册机制和插件发现机制。 feflow要求插件必须以feflow-plugin-开头或者generator-开头，generator作为一种特殊的插件，插件代码以npm包的形式存储和管理。运行feflow install plugin命令时，会通过npm的register检查是否存在插件，如果存在，会检查当前插件是否是最新版本。如果不是最新版本，则会提示用户是否需要更新。然后将插件下载到Home目录下的.feflow目录（windows系统为C:\\Users\\username\\.feflow目录）下的node_modules里面，并且写入到配置文件里面。 本地模块注册机制 本地模块发现机制 常用第三方包分享 osenv 方便获取不同系统的环境和目录配置 figlet 命令行炫酷的Logo生成器 meow 命令封装 inquire 强大的用户交互 chalk 让命令行的output带有颜色 easytable 表格信息展示，用于升级包的提示 minimlist 用户输入的参数解析 shelljs Node.js执行shell命令 clui 进度条 遇到问题 windows下用户未设置HOME环境变量导致报错解决办法: 由于windows下HOME环境变量并非默认存在，因此不能直接使用。判断process.platform === ‘win32'，优先使用HOME变量，否则使用USERPROFILE变量；建议使用osenv这个包。 OSX平台运行feflow报错: env: node\\r: No such file or directory解决办法: 由于类unix系统的换行符号为\\n，而windows系统为\\n\\r。修复换行问题。可以在工程根目录下加.gitattributes文件，设置* text eol=lf，这样git提交时就不会讲LF转换成CRLF powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-framework.html":{"url":"src/node-framework.html","title":"Framework","keywords":"","body":"Framework powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-framework-hapi.html":{"url":"src/node-framework-hapi.html","title":"Hapi Js Framework","keywords":"","body":"Introdction warlmart团队使用了10 CPU cores 和 28GB内存，比较轻松的扛住了Black Friday的流量。 与express的对比 用hapi写api时，有种代码既文档的感觉，而且这些代码也真的可以自动生成 swagger文档。配合hapi-swagger插件，简单配置下插件，swagger文档可自动生成。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-electrode.html":{"url":"src/node-electrode.html","title":"Electrode JS","keywords":"","body":"Electrode powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-electrode-platform.html":{"url":"src/node-electrode-platform.html","title":"Electrode Platform","keywords":"","body":"Electrode precondition：universal React/Node.js application What is Electrode Electrode is a platform for building large scale Universal React web applications with a standardized structure that follows best practices and has modern technologies baked in. Electrode focuses on performance, component reusability, and simple deployment to multiple cloud providers—so you can focus on what makes your app unique. Why use Electrode If you're writing a universal React/Node.js application, then Electrode is for you! Universal JavaScriptfocus on Universal JavaScript SEO Reusability Maintainability Code/UI Reuse Server Side Rendering(SSR) Performance Fast Startup and Deployment Three Pillars Requirements What are Archetypes Archetypes are npm modules that contain the typical standard stuff you would have to add to every new project you create. They encapsulate boilerplates for centralizing your project configurations, workflows, and dependencies. Stand alone Modules Confippet Above The Fold Rendering Server Side Render Caching + Profiling Stateless CSRF Validation Redux Router Engine Powerful Electrode Tools Electrify Electrode Explorer Bundle Analyzer Electrode 提供了什么 一个易用的工作流，从而更加专注于代码，而不是环境。 Alone Modules Functionality Powerful Electrode Tools Node Framework electrode-server hapi已配置为中心，配置优于编码，业务逻辑和传输层进行分离；内置用于构建waeb和service应用的庞大的插件(验证、鉴权、和其他基础设施) express Lerna Lerna 是用来优化托管在git\\npm上的多package代码库的工作流的一个管理工具，可以让你在主项目下管理多个子项目，从而解决了多个包相互依赖，且发布时需要手动维护多个包的问题。 前端 React semantic-ui-react redux(flux的实现) react-router ... 同时使用react 的controler-view模式，只用来保存状态，然后将其转发给子组件。一定程度上提高component view 层的重用性。 xenv-configwebpack-config-composer powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-electrode-question.html":{"url":"src/node-electrode-question.html","title":"Electrode Question","keywords":"","body":"Electrode Question css Modules 編譯問題 .css 後綴會使用css modules；而 .styl 後綴使用 stylus；因而考慮倘若使用了 semantic等 UI 庫時選擇 .styl（前提是外部加載UI庫css文件） powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-redux.html":{"url":"src/node-redux.html","title":"Redux","keywords":"","body":"Redux powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-redux-basic.html":{"url":"src/node-redux-basic.html","title":"Redux Basic Usage","keywords":"","body":"Redux 基本用法 React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。他没有涉及 代码结构 和 组件之间的通信。对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念，已发了很多的实现。2015年， Redux 出现，将 Flux 与函数式编程结合在一起，很短时间内就成为了最热门的前端架构。 首先明确一点， Redux 是一个很有用的架构，但不是费用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。 以下这些情况不需要使用 Redux： 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层 （View）只从单一来源获取数据 以下这些情况是 Redux 的适用场景：多交互、多数据源。 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了 WebSocket View 要从多个来源获取数据 从组件角度出发，如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 预备知识 Redux 文档Redux 视频前30，后30 设计思想 Web 应用是一个状态机，视图与状态是一一对应的。 所有的状体，保存在一个对象里面。 基本概念和 API Store Store 就是数据保存的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 提供 createStore 这个函数，用来生成 Store。 import { createStore } from 'redux'; const store = createStore(fn); // createStore 函数接收另一个函数作为参数，返回新生成的 Store 对象 State Store 对象班含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 import { createStore } from 'redux'; const store = createStore(fn); const state = store.getState(); // 当前时刻的 State ，可以通过 store.getState() 拿到 Redux 规定，一个 State 对应一个 View。只要 State 相同， View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 Action State 的变化，会导致 View 的变化。但是，用户接触不到 State， 所有 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 Action Creator View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action,这个函数就叫 Action Creator。 const ADD_TODO = '添加 TODO'; function addTodo(text) { return { type: ADD_TODO, text } } const action = addTodo('Learn Redux'); // addTodo 函数就是一个 Action Creator store.dispatch Store.dispatch() 是 View 发出 Action 的唯一方法。 import { createStore } from 'redux'; const store = createStore(fn); store.dispatch({ type: 'ADD_TODO', payload: 'Learn Redux' }); // store.dispatch 接收一个 Action 对象作为参数，将它发送出去 // 结合 Action Creator，改写代码 store.dispatch(addTodo('Learn Redux')); Reduxcer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。Reducer 是一个函数它接收 Action 和当前 State 作为参数，返回一个新的 State。 const reducer = function (state, action) { // ... return new_state; } 整个应用的初始状态，可以作为 State 的默认值。 const defaultState = 0; const reducer = (state = defaultState, action) => { switch (action.type) { case 'ADD': return state + action.payload; default: return state; } }; const state = reducer(1, { type: 'ADD', payload: 2 }); 实际应用中， Reducer 函数不用像上面这样手动调用，store.dispatch 方法会触发 Reducer 的自动执行。为此， Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入 createStore 方法。 import { createStore } from 'redux'; const store = createStore(reducer); 为什么这个函数叫做 Reducer 呢？因为他可以作为数组的 reduce 方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。 const actions = [ {type: 'ADD', payload: 0}, {type: 'ADD', payload: 1}, {type: 'ADD', payload: 2}, ]; const total = actions.reduce(reducer, 0);// 3 纯函数 Reducer 函数最重要的特征是，他是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。春函数是函数式编程，必须遵守以下一些约束。 不得改写参数 不能调用系统 I/O 的 API 不能调用 Date.now() 或者 Math.random() 等不纯的方法，因为每次会得到不一样的结果 Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法： // State 是一个对象 function reducer(state, action) { return Object.assign({}, state, { thingToChange }); // 或者 return { ...state, ...newState }; } // State 是一个数组 function reducer(state, action) { return [...state, newItem]; } 某个 View 对应的 State 总是一个不变的对象。 store.subscribe() Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。 import { createStore } from 'redux'; const store = createStore(reducer); store.subscribe(listener); 解除监听：store.subscribe 方法返回一个函数，调用这个函数就可以解除监听了。 Store的实现 let store = createStore(todoApp, window.STATE_FROM_SERVER); // window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，他会覆盖 Reducer 函数的默认初始值。 下面是 createStore 方法的一个简单实现，可以了解一下 Store 是怎么生成的。 const createStore = (reducer) => { let state; let listeners = []; const getState = () => state; const dispatch = (action) => { state = reducer(state, action); listeners.forEach(listener => listener()); }; const suvscribe = (listener) => { listeners.push(listener); return () => { listeners = listeners.filter(l => l !== listener); } }; dispatch({}); return { getState, dispatch, subscribe }; }; Reducer 的拆分 combineReducer 的简单实现： const combineReducers = reducers => { return (state = {}, action) => { return Object.keys(Reducers).reduce( (nextState, key) => { nextState[key] = reducers[key](state[key], action); return nextState; } ); } }; powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-redux-middleware.html":{"url":"src/node-redux-middleware.html","title":"Middleware And Asynchronous","keywords":"","body":"Redux 中间件与异步操作 Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。 View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。 Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 中间件的用法 import { applyMiddlerware, createStore } from 'redux'; import createLogger from 'redux-logger'; const logger = creteLogger(); const store = createStore( reducer, applyMiddleware(logger) ); 注意： createStore 方法可以接受整个应用的初始状态作为参数，那样的话， applyMiddleware 就是第三个参数了。 中间件的次序有讲究。 applyMiddlewares() export default function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action) }; chain = middlewares.map(middleware => middleware(middlerwareAPI)); dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch } } } 所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。 异步操作的基本思路 redux-thunk redux-promise powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-react-redux.html":{"url":"src/node-react-redux.html","title":"React-Redux 的用法","keywords":"","body":"Redux React-Redux 的用法 UI组件 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 容器组件 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API connect() React-Redux 提供 connect 方法， 用于从 UI 组件生成容器组件。 connect 的意思，就是将这两种组件连起来。 import { connect } from 'react-redux'; const VisibleTodoList = connect()(TodoList); 为了定义业务逻辑需要给出下面的信息： 输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数 输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。 因此， connect 方法的完整 API 如下： import { connect } from 'react-redux'; const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps )(TodoList); connect 方法接受两个参数： mapStateToProps 和mapDispatchToProps 。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 Provider 组件 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-npm.html":{"url":"src/node-npm.html","title":"NPM","keywords":"","body":"NPM Package powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-package.html":{"url":"src/node-package.html","title":"package.json","keywords":"","body":"package.json name The name must be less than or equal to 214 characters. This includes the scope for scoped packages. The name can't start with a dot or an underscore. New packages must not have uppercase letters in the name. The name ends up being part of a URL, an argument on the command line, and a folder name. Therefore, the name can't contain any non-URL-safe characters. version description keywords homepage bugs { \"url\" : \"https://github.com/owner/project/issues\", \"email\" : \"project@hostname.com\" } license author, contributors { \"name\" : \"Barney Rubble\", \"email\" : \"b@rubble.com\", \"url\" : \"http://barnyrubble.tumblr.com/\" } // shorten \"Barney Rubble (http://barnyrubble.tumblr.com/)\" files files > .npmignore > .gitignore always included files package.json README CHANGES / CHANGELOG /HISTORY LICENSE / LICENCE NOTICE The file in the \"main\" field always ignored files .git CVS .svn .hg .lock-wscript .wafpickle-N .*.swp .DS_Store ._* npm-debug.log .npmrc node_modules config.gypi *.orig package-lock.json (use shrinkwrap instead) main browser bin { \"bin\" : { \"myapp\" : \"./cli.js\" } } If you have a single executable, and its name should be the name of the package, then you can just supply it as a string { \"name\": \"my-program\", \"version\": \"1.2.5\", \"bin\": \"./path/to/program\" } would be the same as this: { \"name\": \"my-program\", \"version\": \"1.2.5\", \"bin\" : { \"my-program\" : \"./path/to/program\" } } man Specify either a single file or an array of filenames to put in place for the man program to find directories directories.lib directories.bin directories.man directories.doc directories.example directories.test repository \"repository\": { \"type\" : \"git\", \"url\" : \"https://github.com/npm/cli.git\" } \"repository\": { \"type\" : \"svn\", \"url\" : \"https://v8.googlecode.com/svn/trunk/\" } \"repository\": { \"type\" : \"git\", \"url\" : \"https://github.com/facebook/react.git\", \"directory\": \"packages/react-dom\" } shortcut syntax \"repository\": \"npm/npm\" \"repository\": \"github:user/repo\" \"repository\": \"gist:11081aaa281\" \"repository\": \"bitbucket:user/repo\" \"repository\": \"gitlab:user/repo\" scripts config dependencies devDependencies peerDependencies bundledDependencies optionalDependencies engines { \"engines\" : { \"node\" : \">=0.10.3 engineStrict This feature was removed in npm 3.0.0 os process.platform // white list \"os\" : [ \"darwin\", \"linux\" ] // black list \"os\" : [ \"!win32\" ] cpu process.arch preferGlobal DEPRECATED private publishConfig powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-npm-semver.html":{"url":"src/node-npm-semver.html","title":"semver","keywords":"","body":"semver 語義化版本（Semantic Versioning）規範的一個實現，實現了版本和版本範圍的解析、計算、比較。 semver 定義了兩種概念： 版本是指例如0.4.1、1.2.7、1.2.4-beta.0 這樣表示包的特定版本的字符串。 範圍則是對滿足特定規則的版本的一種表示，例如 1.2.3-2.3.4、1.x、^0.2、>1.4。 用semver 去比較版本將會是一個很好的選擇： plugin.forEach(function () { if (!semver.satisfies(platformVersion, plugin.engines.platform)) { console.log(plugin.name, 'require', plugin.engines.platform, 'but unable to meet'); } }) 在你使用express 設計一個支持多版本的API服務器時，你可以這樣做： app.get('/', appVersion(' 選擇semver 的禮由很簡單， 讓裝專業的包去完成專業的工作 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-webpack.html":{"url":"src/node-webpack.html","title":"Webpack","keywords":"","body":"Webpack powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-webpack-plugin.html":{"url":"src/node-webpack-plugin.html","title":"编写插件","keywords":"","body":"编写插件 基础插件 编写示例 class BasicPlugin { // 从构造函数中获取用户设置的配置 constructor (options) { } // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 apply (compiler) { compiler.hooks.compilation.tap('BasicPlugin', compilation => { }) } } // 导出 Plugin module.exports = BasicPlugin 使用示例 const BasicPlugin = require('./BasicPlugin.js') module.exports = { plugins: [ new BasicPlugin(options) ] } Compiler 和 Compilation CompilerCompiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例 CompilationCompilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象 区别Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译 事件流 开发插件时注意事项 只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用 传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件 有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程(v3.8.1) 常用 API 读取输出资源、代码块、模块及其依赖 class Plugin { apply (compiler) { compliler.hooks.emit('Plugin', compilation => { // 存放所有代码块，是一个数组 compilation.chunks.forEach(function (chunk) { // chunk 代表一个代码块 // 代码块有多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块 chunk.forEachModule(module => { // module 代表一个模块 // module.fileDependencies 存在当前模块的所有依赖的文件路径，是一个[] module.fileDependenciew.forEach(filepath => { }) }) }) }) // Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件 // 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时， // 该 Chunk 就会生成 .js 和 .css 两个文件 chunk.files.forEach(function (filename) { // compilation.assets 存放当前所有即将输出的资源 // 调用一个输出资源的 source() 方法能获取到输出资源的内容 let source = compilation.assets[filename].source(); }) } } chunk 字段 { id: 0, ids: [ 0 ], debugId: 1003, name: 'app', preventIntegration: false, entryModule: { // NormalModule { dependencies: [], blocks: [], variables: [], type: '', ... } }, _modules: Set { // CssModule { dependencies: [], blocks: [], type: 'css/mini-extract' }, // NormalModule { type: 'javascript/auto' } // ConcatenatedModule { type: 'javascript/esm' } ... }, files: [], rendered: true, hash: 'hash 32', contentHash: } module 字段 { dependencies: [], blocks: [], variables: [], type: '', context: '' | null, debugId: 1041, hash: 'hash 32', renderedHash: 'hash 20', resolveOptions: {} , factoryMeta: {}, warnings: [], errors: [], buildMeta: {}, buildInfo: { strict: true, cacheable: true, moduleArgument: undefined, exportsArgument: '__webpack_exports__', fileDependencies: Set {}, contextDependencies: Set {}, assets: undefined, }, reasons: [ { // ModuleReason module: [NormalModule], dependency: [], explanation: undefined, _chunks: null } ], _chunks: Set { { // Chunk id: 0, ids: [Array], debugId: 1003, name: 'app', preventIntegration: false, entryModule: [NormalModule], _modules: [SortableSet], filenameTemplate: undefined, _groups: [SortableSet], files: [Array], rendered: true, hash: '4be1571b7464f812b1b2e7cc00a6bc04', contentHash: [Object], renderedHash: '4be1571b7464f812b1b2', chunkReason: undefined, extraAsync: false, removedModules: undefined }, _lastActiveSortFn: null, _sortFn: [Function: sortById], _cache: undefined, _cacheOrderIndependent: undefined } }, id: 15, index: 21, index2: 28, depth: 1, issuer: null, profile: undefined, prefetched: false, built: true, used: true, usedExports: true, optimizationBailout: [], _rewriteChunkInReasons: undefined, useSourceMap: false, _source: null, rootModule: { // NormalModule { dependencies: [], ... } } } 监听文件变化 // // 当依赖的文件发生变化时会触发 watch-run 事件 compiler.hooks.watchRun.tap('Plugin', watching => { // 获取发生变化的文件列表 const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes // changedFiles 格式为键值对，键为发生变化的文件路径。 if (changedFiles[filePath] !== undefined) { // filePath 对应的文件发生了变化 } }) compiler.hooks.afterCompile.tap('Plugin', (compilation) => { // 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译 compilation.fileDependencies.push(filePath) }) 修改输出资源 compiler.hooks.emit.tap('Plugin', (compilation) => { // 设置名称为 fileName 的输出资源 compilation.assets[fileName] = { // 返回文件内容 source: () => { // fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer return fileContent; }, // 返回文件大小 size: () => { return Buffer.byteLength(fileContent, 'utf8'); } } // 读取 compilation.assets // 读取名称为 fileName 的输出资源 const asset = compilation.assets[fileName] // 获取输出资源的内容 asset.source() // 获取输出资源的文件大小 asset.size() }) 判断 Webpack 使用了哪些插件 // 判断当前配置使用使用了 ExtractTextPlugin， // compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数 function hasExtractTextPlugin(compiler) { // 当前配置所有使用的插件列表 const plugins = compiler.options.plugins; // 去 plugins 中寻找有没有 ExtractTextPlugin 的实例 return plugins.find(plugin=>plugin.__proto__.constructor === ExtractTextPlugin) != null; } powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/node-isomorphism-render.html":{"url":"src/node-isomorphism-render.html","title":"同构渲染","keywords":"","body":"同构渲染 SPA对比于SSR 所以相比于 SPA，服务器端渲染从直观上看: 转化 HTML 到 DOM，浏览器原生会比 JavaScript 生成 DOM 的时间短 省去了 SPA 中 JavaScript 的请求与编译时间 解决 软件开发中遇到的所有问题，都可以通过增加一层抽象而得以解决 模板的方式是 F 只执行一遍，而组件方式则为每次 data 改变都会再执行一遍无论是模板方式还是组件方式，前后端同构的方案都呼之欲出，我们在 Node.js 端获取数据 ，执行 F 函数，得到 HTML输出给浏览器，浏览器 JavaScript 复用 HTML，继续执行 F 函数，等到数据变化，继续执行 F 函数，交互也得到解决 实施 通用代码 分为两个入口，分为服务端和客户端，只引入通用代码，然后在不同的环境里调用各自的渲染函数。当然，在客户端 ReactDOM.render 会生成 DOM 结构，而服务器端通过 ReactServer.renderToString 将生成 HTML，需要由 HTTP Server 推给前端，各入口处解决特异的环境问题； 通用代码中不可在不判定执行环境的情况下引用 DOM、调用 window、document 这些浏览器特异和引用 global process 这些服务器端特异的操作，这往往是引起 Node.js 服务出问题的根本原因； 为了兼容两端，在选择库时，需要也同时需要支持两端，比如 axios，lodash 等； React 和 Vue 都有生命周期，需要区分哪些生命周期是在浏览器中运行，哪些会在服务器端运行，或者是同时运行，如使用 Redux 或者 Vuex 等库，最好在组件上引入 asyncData 钩子进行数据请求，同时供两端使用； 判定不同的执行环境可以通过注入 process.env.EXEC_ENV 来解决 构建与运行 在使用 webpack 进行构建时，需要将公共 App 部分打包出来，形成公共代码，由服务器端引入执行，而客户端可以引用打包好的公共代码，再用 webpack 引入之后进行特异处理即可； 需要引入 Node.js 中间层，负责请求数据，提供渲染能力，提供 HTTP 服务，由于 HTML 模板需要在服务端引入，CDN 文件需要自行处理； 至于 babel 的使用，可以在浏览器中通用处理，服务端只解决特殊语法，如 jsx，vue template 参考文献 【第1560期】前端同构渲染的思考与实践 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/service-terminal.html":{"url":"src/service-terminal.html","title":"服务端","keywords":"","body":"服务端 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/docker.html":{"url":"src/docker.html","title":"Docker","keywords":"","body":"Docker 简介 1. docker commit 2. 使用默认网络配置启动容器 3. 管理容器的数据 4. Dockerfile 指令详解 5. Compose 简介 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口。 一个完整的 Docker 有以下几个部分组成： dockerClient 客户端 Docker Daemon 守护进程 Docker Image 镜像 DockerContainer 容器 1. docker commit 通过 commit 创建容器的一个小缺陷,不能自动执行命令或添加 entrypoint; commit 创建镜像时添加自动运行CMD和entrypoint (-c --change string) 2. 使用默认网络配置启动容器 通过使用网络驱动,docker包含了对容器网络的支持.默认情况下,docker为容器提供了两种网络模式: 桥接(bridge)网络 和 覆盖(overlay)网络 你也可以使用自定义网络驱动插件创建自定义的网络支持,不过这属于高级行为. 3. 管理容器的数据 docker Engine 提供了两种方式管理容器的数据: 数据卷 数据卷容器 3.1 数据卷 数据卷是一个或多个容器绕过 Union File System 而指定的一个特殊目录. 数据卷为数据持久化和共享提供了一些有用的功能. 卷在创建容器的时候被初始化.如果容器的基础镜像在卷的挂载点目录中有数据,那么这些数据会哦被复制到初始化后的卷上. 数据卷可以在容器之间共享和复用 数据卷的修改实时生效 更新镜像时不会影响数据卷 即使容器被删除数据卷也会存在 数据卷是为了在容器生命周期内,数据的持久化,独立性而设计的. 因此docker永远不会在删除容器的时候删除数据卷. 也不会将数据卷放入 \"回收站\"而不让容器重新使用. 3.2 添加数据卷 在使用 dcoker creaste 或 docker run 命令的时候,使用 -v标识可以为容器添加数据卷.多次使用 -v 可以为容器添加多个数据卷. 4. Dockerfile 指令详解 4.1. COPY 复制文件 格式: COPY ... COPY [\"\",... \"\"] 4.2. ADD 更高级的复制文件 附加 解压等复杂功能 4.3. CMD 容器启动命令 CMD 指令的格式和 RUN 相似,也是两种格式: shell 格式:　 CMD exec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...] 参数列表格式：CMD [\"参数1\", \"参数2\"...]。在指定 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 4.4 ENTRYPOINT 入口点 ENTRYPOINT 的格式和 RUN指令格式一样, 分为 exec 格式和shell 格式.ENTRYPOINT的目的和 CMD一样,都是在指定容器启动程序及参数.ENTRYPOINT 在运行时也可以替代,不过比CMD要略显繁琐,需要通过 docker run 的参数 --entrypoint 来指定.当指定了 entrypoint 后,CMD 的含义就发生了改变,不再是直接的运行其命令,而是将CMD 的内容作为参数传给 entrypoint 指令, 换句话说实际执行时,将变为:　 \"\" 4.5 ENV 设置环境变量 格式有两种：　　 ENV ENV = = 4.6 ARG 构建参数 格式: ARG [=] 4.7 VOLUME 定义匿名卷 格式: VOLUME [\"\", \"\"...] VOLUME 4.8 EXPOSE 声明端口 格式: EXPOSE [...] 4.9 WORKDIR 指定工作目录 格式: WORKDIR 4.10 USER 指定当前用户 4.11 HEALTHCHECK 健康检查 HEALTHCHECK [选项] CMD :　设置检查容器健康状况的命令 HEALTHCHECK NONE:　如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查命令指令 4.12 ONBUILD 为他人做嫁衣裳 5. Compose Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 5.1 Compose 命令说明 5.1.1 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。 5.1.2 命令使用说明 build config 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。 down 此命令将会停止 up 命令所启动的容器，并移除网络 exec 进入指定的容器。 help 获得一个命令的帮助。 images 列出 Compose 文件中包含的镜像。 kill 格式: docker-compose kill [options] [SERVICE...]。 通过发送 SIGKILL 信号来强制停止服务容器。 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。 logs 格式: docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 选项： --no-color 来关闭颜色 pause 格式: docker-compose pause [SERVICE...]。 暂停一个服务容器。 port 格式: docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 ps 格式: docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： q 只打印容器的 ID 信息。 pull 格式: docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 push 推送服务依赖的镜像到 Docker 镜像仓库。 restart 格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 rm run 格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 docker-compose run ubuntu ping docker.com scale start stop top 查看各个服务容器内运行的进程 unpause 格式: docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 up 它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作 -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 version 打印版本信息 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/inotify.html":{"url":"src/inotify.html","title":"Inotify","keywords":"","body":"Inotify 高效、實時的Linux 文件系統事件監控框架 概要 1. 爲什麼需要監控文件系統？人們需要知道在某些文件（夾）上都有哪些變化，比如： 通知配置文件的改變 跟蹤某些關鍵的系統文件的變化 監控某個分區磁盤的整體使用情況 系統崩潰時進行自動清理 自動觸發備份進程 向服務器上傳文件結束時發出通知 通常使用文件輪詢的通知機制，但是這種機制只適用於經常改變的文件（因爲它可以確保每過x秒就可以得到i/o），其他情況下都非常低效，並且有時候會丟失某些類型的變化，例如文件的修改時間沒有改變。像 Tripwire這樣的數據完整性系統，他們基於時間調度來跟蹤文件變化，但是如果想實時監控的變化的話，那麼時間調度就束手無策了。Inotify 就這樣應運而生。 2. Inotify到底是什麼?Inotify是一種文件變化通知機制，Linux內核從2.6.13開始引入。在BSD和Mac OS系統中比較有名的是kqueue，它可以高效的實時跟蹤Linux文件系統的變化。近些年來，以fsnotify 作爲後端，幾乎所有的主流Linux發行版都支持Inotify 機制。如何知道你的Linux 內核是否支持Inotify機制呢 % grep INOTIFY_USER /boot/config-$(uname -r) CONFIG_INOTIFY_USER=y inotifywait -rme modify,attrib,move,close_write,create,delete,delete_self /srv/test 總結 綜上所述，Inotify爲Linux提供了一套高效監控和跟蹤文件變化機制，他可以實時的處理、調試以及監控文件變化，而輪詢是一種延遲機制。對於系統管理員，關於實現事件驅動的服務和系統備份，構建服務以及基於文件操作的程序調試等，inotify無疑提供了強大的支持。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/linux.html":{"url":"src/linux.html","title":"Linux","keywords":"","body":"Linux unbuntu 中管理用户和用户组 添加一个用户并指定 id 为1002 sudo groupadd -g 1002 www 添加一个用户到 www 组并指定 id 为 1003 sudo useradd wyx -g 1002 -u 1003 -m 修改用户密码 sudo passwd wyx 删除一个用户 sudo userdel wyx 为该用户添加 sudo 权限 sudo usermod -a -G adm wyx sudo usermod -a -G sudo wyx 查看所有用户和用户组： cat /etc/passwd cat /etc/group ubuntu 设置当前用户sudo免密码 备份 /etc/sudoers sudo cp /etc/sudoers . 打开 /etc/sudoers sudo visudo 在文件末尾加入linuxidc ALL=NOPASSWD:ALL ubutun默认root密码修改 sudo passwd ubuntu 解决网页音频无法播放 # 解码器 sudo apt-get install ubuntu-restricted-extras powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/nginx.html":{"url":"src/nginx.html","title":"Nginx","keywords":"","body":"Nginx powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/nginx-readme.html":{"url":"src/nginx-readme.html","title":"Nginx简介","keywords":"","body":"Nginx简介 Nginx简介及使用Nginx实现负载均衡的原理 1-环境 2-针对不同请求的负载均衡 3-访问同一页面的负载均衡 两种均衡 学习笔记 简介 架构 基础概念 配置 nginx 这个轻量级、高性能的 web server 主要可以干两件事： 直接作为http server(代替apache，对PHP需要FastCGI处理器支持)； 另外一个功能就是作为反向代理服务器实现负载均衡； Nginx简介及使用Nginx实现负载均衡的原理 1) 环境 我们本地是Windows系统，然后使用VirutalBox安装一个虚拟的Linux系统。 　　在本地的Windows系统上分别安装nginx(侦听8080端口)和apache(侦听80端口)。在虚拟的Linux系统上安装apache(侦听80端口)。这样我们相当于拥有了1台nginx在前端作为反向代理服务器；后面有2台apache作为应用程序服务器(可以看作是小型的server cluster。;-) )； nginx用来作为反向代理服务器，放置到两台apache之前，作为用户访问的入口； nginx仅仅处理静态页面，动态的页面(php请求)统统都交付给后台的两台apache来处理。　也就是说，可以把我们网站的静态页面或者文件放置到nginx的目录下；动态的页面和数据库访问都保留到后台的apache服务器上。 如下介绍两种方法实现server cluster的负载均衡。 我们假设前端nginx(为127.0.0.1:80)仅仅包含一个静态页面index.html；　后台的两个apache服务器(分别为localhost:80和158.37.70.143:80)，一台根目录放置phpMyAdmin文件夹和test.php(里面测试代码为print “server1“;)，另一台根目录仅仅放置一个test.php(里面测试代码为 print “server2“;)。 2) 针对不同请求 的负载均衡 在最简单地构建反向代理的时候 (nginx仅仅处理静态不处理动态内容，动态内容交给后台的apache server来处理)，我们具体的设置为：在nginx.conf中修改: 　　location ~ \\.php$ { 　　proxy_pass 158.37.70.143:80 ; 　　} 这样当客户端访问localhost:8080/index.html的时候，前端的nginx会自动进行响应；当用户访问localhost:8080/test.php的时候(这个时候nginx目录下根本就没有该文件)，但是通过上面的设置 location ~ .php$(表示正则表达式匹配以.php结尾的文件，详情参看location是如何定义和匹配的http://wiki.nginx.org/NginxHttpCoreModule) ，nginx服务器会自动pass给 158.37.70.143的apache服务器了。该服务器下的test.php就会被自动解析，然后将html的结果页面返回给nginx，然后 nginx进行显示(如果nginx使用memcached模块或者squid还可以支持缓存)，输出结果为打印server2。如上是最为简单的使用nginx做为反向代理服务器的例子； 们现在对如上例子进行扩展，使其支持如上的两台服务器。我们设置nginx.conf的server模块部分，将对应部分修改为： 　　location ^~ /phpMyAdmin/ { 　　proxy_pass 127.0.0.1:80 ; 　　} 　　location ~ \\.php$ { 　　proxy_pass 158.37.70.143:80 ; 　　} 上面第一个部分location ^~ /phpMyAdmin/，表示不使用正则表达式匹配(^~)，而是直接匹配，也就是如果客户端访问的 URL是以http://localhost:8080/phpMyAdmin/ 开头的话(本地的nginx目录下根本没有phpMyAdmin目录)，nginx会自动pass到127.0.0.1:80 的Apache服务器，该服务器对phpMyAdmin目录下的页面进行解析，然后将结果发送给nginx，后者显示；如果客户端访问URL是http://localhost/test.php 的话，则会被pass到158.37.70.143:80 的apache进行处理。 　　因此综上，我们实现了针对不同请求的负载均衡。　　〉如果用户访问静态页面index.html，最前端的nginx直接进行响应； 　　〉如果用户访问test.php页面的话，158.37.70.143:80 的Apache进行响应； 　　〉如果用户访问目录phpMyAdmin下的页面的话，127.0.0.1:80 的Apache进行响应； 3) 访问同一页面 的负载均衡 即用户访问http://localhost:8080/test.php 这个同一页面的时候，我们实现两台服务器的负载均衡 (实际情况中，这两个服务器上的数据要求同步一致，这里我们分别定义了打印server1和server2是为了进行辨认区别)。 现在我们的情况是在windows下nginx是localhost侦听8080端口；　　两台apache，一台是127.0.0.1:80(包含test.php页面但是打印server1)，另一台是虚拟机的158.37.70.143:80(包含test.php页面但是打印server2)。 因此重新配置nginx.conf为： 首先在nginx的配置文件nginx.conf的http模块中添加，服务器集群server cluster(我们这里是两台)的定义： 复制代码 代码如下: upstream myCluster { 　　server 127.0.0.1:80 ; 　　server 158.37.70.143:80 ; 　　} 表示这个server cluster包含2台服务器，然后在server模块中定义，负载均衡：复制代码 代码如下: 　　location ~ \\.php$ { 　　proxy_pass http://myCluster ; #这里的名字和上面的cluster的名字相同 　　proxy_redirect off; 　　proxy_set_header Host $host; 　　proxy_set_header X-Real-IP $remote_addr; 　　proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 　　} 这样的话，如果访问http://localhost:8080/test.php 页面的话，nginx目录下根本没有该文件，但是它会自动将pass到myCluster定义的服务区机群中，分别由127.0.0.1:80;或者158.37.70.143:80;来做处理。上面在定义upstream的时候每个server之后没有定义权重，表示两者均衡；如果希望某个更多响应的话例如：复制代码 代码如下: 　　upstream myCluster { 　　server 127.0.0.1:80 weight=5; 　　server 158.37.70.143:80 ; 　　} 这样表示5/6的几率访问第一个server,1/6访问第二个。另外还可以定义max_fails和fail_timeout等参数。综上，我们使用nginx的反向代理服务器reverse proxy server的功能，将其布置到多台apache server的前端。nginx仅仅用来处理静态页面响应和动态请求的代理pass，后台的apache server作为app server来对前台pass过来的动态页面进行处理并返回给nginx。通过以上的架构，我们可以实现nginx和多台apache构成的机群cluster的负载均衡。 两种均衡 可以在nginx中定义访问不同的内容，代理到不同的后台server； 如上例子中的访问phpMyAdmin目录代理到第一台server上；访问test.php代理到第二台server上； 可以在nginx中定义访问同一页面，均衡 (当然如果服务器性能不同可以定义权重来均衡)地代理到不同的后台server上。 如上的例子访问test.php页面，会均衡地代理到server1或者server2上。实际应用中，server1和server2上分别保留相同的app程序和数据，需要考虑两者的数据同步 学习笔记 简介 Nginx 是一款轻量级的 Web （HTTP）服务器/反向代理服务器及 电子邮件（IMAP/POP3) 代理服务器 关键字： 事件驱动 反向代理 负载平衡 响应静态页面的速度非常快 优势：能支持高达 50,000 个并发连接数 ；支持热部署 ；很高的稳定性（抵御dos攻击） 架构 在 unix 系统中会以 daemon （守护进程）的方式在后台运行，后台进程包含 一个 master 进程和多个 worker 进程（多进程的工作方式） 多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。 一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。 推荐设置 worker 的个数为 cpu 的核数 异步非阻塞 （非阻塞不会让出cpu导致切换浪费） 基础概念 connection 是对 tcp 连接的封装; Nginx 通过设置 worker_connectons 来设置每个worker进程支持的最大连接数; Nginx 能建立的最大连接数，应该是 worker_connections worker_processes ;对于 HTTP 请求本地资源来说，能够支持的最大并发数量是 worker_connections worker_processes ，而如果是 HTTP 作为反向代理来说，最大并发数量应该是 worker_connections worker_processes/2* 。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接; request Nginx 中指 http 请求; web服务器工作流：http 请求是典型的请求-响应类型的的网络协议，而 http 是文本协议，所以我们在分析请求行与请求头，以及输出响应行与响应头，往往是一行一行的进行处理。如果我们自己来写一个 http 服务器，通常在一个连接建立好后，客户端会发送请求过来。然后我们读取一行数据，分析出请求行中包含的 method、uri、http_version 信息。然后再一行一行处理请求头，并根据请求 method 与请求头的信息来决定是否有请求体以及请求体的长度，然后再去读取请求体。得到请求后，我们处理请求产生需要输出的数据，然后再生成响应行，响应头以及响应体。在将响应发送给客户端之后，一个完整的请求就处理完了。 keepalive 长连接:http 请求是基于 TCP 协议之上的，那么，当客户端在发起请求前，需要先与服务端建立 TCP 连接(三次握手)，当连接断开后（四次挥手）。而 http 请求是请求应答式的，如果我们 能知道每个请求头与响应体的长度 ，那么我们是 可以在一个连接上面执行多个请求的，这就是所谓的长连接 ，但前提条件是我们先得确定请求头与响应体的长度。对于请求来说，如果当前请求需要有body，如 POST 请求，那么 Nginx 就需要客户端在请求头中指定 content-length 来表明 body 的大小，否则返回 400 错误。也就是说，请求体的长度是确定的，那么响应体的长度呢？ 先来看看 http 协议中关于响应 body 长度的确定： 对于 http1.0 协议来说，如果响应头中有 content-length 头，则以 content-length 的长度就可以知道 body 的长度了，客户端在接收 body 时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了。而如果没有 content-length 头，则客户端会一直接收数据，直到服务端主动断开连接，才表示 body 接收完了。 而对于 http1.1 协议来说，如果响应头中的 Transfer-encoding 为 chunked 传输 ，则表示 body 是流式输出，body 会被分成多个块，每块的开始会标识出当前块的长度，此时，body 不需要通过长度来指定。如果是非 chunked 传输，而且有 content-length，则按照 content-length 来接收数据。否则，如果是非 chunked，并且没有 content-length，则客户端接收数据，直到服务端主动断开连接。 从上面，我们可以看到，除了 http1.0 不带 content-length 以及 http1.1 非 chunked 不带 content-length 外，body 的长度是可知的。此时，当服务端在输出完 body 之后，会可以考虑使用长连接。能否使用长连接，也是有条件限制的。如果客户端的请求头中的 connection为close，则表示客户端需要关掉长连接，如果为 keep-alive，则客户端需要打开长连接，如果客户端的请求中没有 connection 这个头，那么根据协议，如果是 http1.0，则默认为 close，如果是 http1.1，则默认为 keep-alive。如果结果为 keepalive，那么，Nginx 在输出完响应体后，会设置当前连接的 keepalive 属性，然后等待客户端下一次请求。当然，Nginx 不可能一直等待下去，如果客户端一直不发数据过来，岂不是一直占用这个连接？所以当 Nginx 设置了 keepalive 等待下一次的请求时，同时也会设置一个最大等待时间，这个时间是通过选项 keepalive_timeout 来配置的，如果配置为 0，则表示关掉 keepalive，此时，http 版本无论是 1.1 还是 1.0，客户端的 connection 不管是 close 还是 keepalive，都会强制为 close。 如果服务端最后的决定是 keepalive 打开，那么在响应的 http 头里面，也会包含有 connection 头域，其值是\"Keep-Alive\"，否则就是\"Close\"。如果 connection 值为 close，那么在 Nginx 响应完数据后，会主动关掉连接。所以，对于请求量比较大的 Nginx 来说，关掉 keepalive 最后会产生比较多的 time-wait 状态的 socket。一般来说，当客户端的一次访问，需要多次访问同一个 server 时，打开 keepalive 的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开 keepalive 也会大量减少 time-wait 的数量。 pipe http1.1 引入新特性,keepalive 的一种升华，基于长连接的，目的就是利用一个连接做多次请求; 对 pipeline 来说，客户端不必等到第一个请求处理完后，就可以马上发起第二个请求; linger_close 延迟关闭，也就是说，当 Nginx 要关闭连接时，并非立即关闭连接，而是先关闭 tcp 连接的写，再等待一段时间后再关掉连接的读。 配置 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/nginx-install.html":{"url":"src/nginx-install.html","title":"Nginx原理、安装预配置","keywords":"","body":"Nginx原理、安装预配置 1. Nginx的模块与工作原理 Nginx由内核和模块组成。内核十分简洁,因此完成的工作相对简单.内核的主要工作就是通过查找配置文件将客户端请求映射到一个location block(location是Nginx配置中的一个指令,用于URI/URL匹配)，而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作.1.1 Nginx的模块结构 核心模块:包括：http模块,event模块和mail模块 基础模块:包括HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy模块和 HTTP Rewrite 模块 第三方模:包括HTTP Upstream Request Hash 模块、Notice 模块 以及HTTP Access Key 模块属于第三方模块,用户根据自己的需要开发的模块都属于第三方模块。 Nginx 的模块从功能上分为三类： Handlers(处理器模块)此类模块直接处理请求,并进行输出内容和修改 headers信息等操作。handlers 处理器模块一般只能有一个。 Filters (过滤器模块)此类模块主要对其他处理器模块输出的内容进行修改操作,最后由 Nginx 输出。 Proxies (代理类模块)就是 Nginx 的 HTTP Upstream 之类的模块,这些模块主要与后端一些服务比如 fastcgi 等操作交互,实现服务代理和负载均衡等功能。 下图展示了 Nginx 的模块处理一次常规的 HTTP 请求和响应的过程： 2. Nginx的模块与工作原理 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/TCP&IP.html":{"url":"src/TCP&IP.html","title":"TCP/IP 协议","keywords":"","body":"TCP/IP协议 高楼大厦，起于平川。不积跬步,无以至千里，不积小流，无以成江海。 什么是TCP/IP 用于机器间通信，制定了各种各样的协议（TCP协议，DNS协议...），有了这些协议，各种数据流按照规则传输，计算机之间得以通信。 TCP/IP协议族中有一个重要的概念：分层，TCP/IP协议按照层次分为以下四层：应用层、传输层、网络层、数据链路层。（封转性、隔离） 下面是从网络上找到的TCP/IP通信数据流 HTTP 关系密切的协议：IP、TCP、和DNS IP协议：192.168.1.1这种数字指的是IP地址。IP协议的作用在于把各种数据包准确无误地传递给对方，其中重要的条件是IP地址和MAC地址（Media Access Control Address） 使用 ARP协议凭借MAC地址进行通信 IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址 你向另一台电脑发送一条信息，怎么在茫茫人海中瞬间找到对方，如下图所示： TCP协议：如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的东西带给对方。各有分工，互不冲突。 按层次分，TCP属于传输层，提供可靠的字节流服务。什么叫字节流服务呢？这个名字听起来让人不知所以然，下面听下我通俗的解释。所谓的字节流，其实就类似于信息切割。比如你是一个卖自行车的，你要去送货。安装好的自行车，太过庞大，又不稳定，容易损伤。不如直接把自行车拆开来，每个零件上都贴上收货人的姓名。最后送到后按照把属于同一个人的自行车再组装起来，这个拆解、运输、拼装的过程其实就是TCP字节流的过程。 我们看下严谨的学术表达是怎样的： 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。 下面我写一段对话来模拟下这三次握手。为了确保信息能够确保准确无误的到达，TCP采用了著名的三次握手策略（three-way handshaking）.下面我写一段对话来模拟下这三次握手。 DNS：DNS(Domain names System) 和HTTP协议一样是处于应用层的服务，提供域名到IP地址之间的解析服务。 下面是我们访问一个网页，各种协议在里面气的作用: powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/http.html":{"url":"src/http.html","title":"HTTP 协议","keywords":"","body":"HTTP 协议 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/http-base.html":{"url":"src/http-base.html","title":"基础概念篇","keywords":"","body":"Http 协议 基础概念篇 介绍 HTTP是Hyper Text Transfer Protocol(超文本传输协议)的缩写。它的发展是万维网协会（World Wide Web Consortinum）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，他们最终发布了一些列RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的是 RFC2616。 RFC 2616 定义了今天普遍使用的一个版本—— HTTP 1.1。 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。他可以使浏览器更加高效，使网络传输减少，还确定传输文档中的哪一部分，以及哪部分内容首先显示（如文本先于图形）等。 在 TCP/IP 协议栈中的位置 HTTP协议通常承载于 TCP 协议之上，有时也承载于 TLS 或 SSL 协议层之上，这个时候就是我们常说的HTTPS。 如下图所示： HTTP 的请求响应模型 这样限制了 HTTP 协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。 HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系的。 工作流程 一次 HTTP 操作称为一个事务。 使用 Wireshark 抓 TCP、 http 包 头域 每个头域有一个域名、冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以坚决爱任何数量的空格符，头域可以被拓展为多行，在每行开始处，使用至少一个空格或制表符。 Host 头域 Host 头域指定请求资源的Internet主机和端口号，必须表示请求url的原始服务器或网关的位置。 HTTP/1.1 请求必须包含主机头域，否则系统会以400状态码返回。 Referer 头域 Referer 头域允许客户端指定请求 uri 的资源源地址，这可以允许服务器生成回退链表，可用来登录、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer 不能被发送。如果指定的是部分 uri 地址，则此地址应该是一个相对地址。 User-Agent 头域 User-Agent 头域的内容包含发出请求的用户信息。 Cache-Control 头域 Cache-COntrol指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括：no-cache、 no-store、 max-age、 max-stale、 min-fresh、 only-if-cached 响应消息中的指令包括：public、 private、 no-cache、 no-store、 no-transform、 must-revalidate、 proxy-revalidate、 max-age Date 头域 Date头域表示消息发送的时间，时间描述格式由 RFC822 定义。 HTTP 的几个重要概念 连接： Connection 一个传输层的实际环流，他是建立在两个相互通讯的应用程序之间。 在 http1.1、 request、和response头中都有可能出现一个 connection 的头，此 header 的含义是当 client 和 server 通信时 对于长链接如何进行处理 。 在 http1.1 中， client 和 server 都是默认对方支持长连接的，如果 client 使用 http1.1 协议，但又不希望使用长连接，则需要在 header 中指明 connection的值为close；如果 server 方也不想支持长连接，则在response中也需要明确说明 connection 的值为 close。不论 request 还是 response 的 header 中包含了值为 close 的 connection，都表明当前正在使用的 tcp 链接在当天请求处理完毕后会被断掉。以后 client 再进行新的请求时就必须创建新的tcp链接了。 消息： Message HTTP 通讯的基本单位，包括一个结构化的八元组序列病通过连接接传输。 请求： Request 一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符、资源的标识符和协议的版本号。 响应： Response 一个从服务器返回的信息包括 HTTP 协议的版本号、请求的状态和文档的 MIME 类型。 资源： Resource 由 URI 标识的网络数据对象或服务。 实体： Entity 数据资源或来自服务资源的回应的一种特殊表示方法，他可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。 客户机： Client 一个为发送请求目的而建立连接的应用程序。 用户代理： UserAgent 初始化一个请求的客户机。他们是浏览器、编辑器或其他用户工具。 服务器： Server 一个接收连接并对请求返回信息的应用程序。 源服务器： Originserver 是一个给定资源可以在其上驻留或被创建的服务器。 代理： Proxy 一个中间程序，他可以充当一个服务器，也可以充当一个客户机，为其他客户机建立请求。请求是通过可能的翻译在内部或经过传递到其他的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。 网关： Gateway 一个作为其他服务器中间媒介的服务器。与代理不同的是，网关接受请求就好像对被请求的资源来说他就是源服务器；发出请求的客户机并没有意识到他在同网关打交道。 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非 HTTP 系统中的资源。 通道： Tunnel 是作为两个连接中继的中介程序。一旦激活，通道便认为不属于HTTP通讯，尽管通道可能是一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户（Portal）必须存在或中介（Intermediary）不能解释中继的通讯时通道被经常使用。 缓存： Cache 反应信息的局域存储。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/http-detail.html":{"url":"src/http-detail.html","title":"协议详解篇","keywords":"","body":"Http 协议 协议详解篇 HTTP/1.0 和 HTTP/1.1 的比较 RFC HTTP version RFC1945 1.0 RFC2616 1.1 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/process.html":{"url":"src/process.html","title":"Process","keywords":"","body":"进程, 线程 1. 进程和线程的区别 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,他是比进程更小的独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 主要差别: 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。 2. 简介 进程（process）是一块包含了某些资源的内存区域。操作系统利用进程把它的工作划分为一些功能单元。 进程 中所包含的一个或多个执行单元称为线程（thread）。进程还拥有一个私有的虚拟地址空间，该空间仅能被它所包含的线程访问。 当运行.NET程序时，进程还会把被称为CLR的软件层包含到它的内存空间中。上一章曾经对CLR做了详细描述。该软件层是在进程创建期间由运行时宿主载入的（参见4.2.3节）。 线程只能归属于一个进程并且它只能访问该进程所拥有的资源。当操作系统创建一个进程后，该进程会自动申请一个名为主线程或首要线程的线程。主线程将执行运行时宿主, 而运行时宿主会负责载入CLR。 应用程序（application）是由 一个或多个相互协作的进程组成的。例如，Visual Studio开发环境就是利用一个进程编辑源文件，并利用另一个进程完成编译工作的应用程序。 在Windows NT/2000/XP操作系统下，我们可以通过任务管理器在任意时间查看所有的应用程序和进程。尽管只打开了几个应用程序，但是通常情况下将有大约30个进程同时运行。 事实上，为了管理当前的会话和任务栏以及其他一些任务，系统执行了大量的进程。 3. 进程3.1 简介 在运行于32位处理器上的32位Windows操作系统中，可将一个进程视为一段大小为4GB（232字节）的线性内存空间，它起始于0x00000000结束于0xFFFFFFFF。这段内存空间不能被其他进程所访问，所以称为该进程的私有空间。这段空间被平分为两块，2GB被系统所有，剩下2GB被用户所有。 如果有N个进程运行在同一台机器上，那么将需要N×4GB的海量RAM，还好事实并非如此。 Windows是按需为每个进程分配内存的，4GB是32位系统中一个进程所占空间的上限。将进程所需的内存划分为4KB大小的内存页，并根据使用情况将这些内存页存储在硬盘上或加载到RAM中，通过系统的这种虚拟内存机制，我们可以有效地减少对实际内存的需求量。当然这些对用户和开发者来说都是透明的。 3.2 System.Diagnostics.Process 类System.Diagnostics.Process类的实例可以引用一个进程，被引用的进程包含以下几种。 该实例的当前进程。 本机上除了当前进程的其他进程。 远程机器上的某个进程。 通过该类所包含的方法和字段，可以创建或销毁一个进程，并且可以获得一个进程的相关信息。下面将讨论一些使用该类实现的常见任务。默认情况下，子进程将继承其父进程的安全上下文。但还可以使用Process.Start()方法的一个重载版本在任意用户的安全上下文中启动该子进程，当然需要通过一个System.Diagnostics. ProcessStartInfo类的实例来提供该用户的用户名和密码 3.3 避免在一台机器上同时运行同一应用程序的多个实例 有些应用程序需要这种功能。实际上，通常来说在同一台机器上同时运行一个应用程序的多个实例并没有意义。 直到现在，为了在Windows下满足上述约束，开发者最常用的方法仍然是使用有名互斥体（named mutex）技术（参见5.7.2节）。然而采用这种技术来满足上述约束存在以下缺点： 该技术具有使互斥体的名字被其他应用程序所使用的较小的、潜在的风险。在这种情况下该技术将不再有效并且会造成很难检测到的bug。 该技术不能解决我们仅允许一个应用程序产生N个实例这种一般的问题。 幸而在System.Diagnostics.Process类中拥有GetCurrentProcess()（返回当前进程）和 GetProcesses()（返回机器上所有的进程）这样的静态方法. 4. 线程4.1 简介 一个线程包含以下内容: 一个指向当前被执行指令的指令指针； 一个栈； 一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值； 一个私有的数据区。 所有这些元素都归于线程执行上下文的名下。处在同一个进程中的所有线程都可以访问该进程所包含的地址空间，当然也包含存储在该空间中的所有资源。 4.2 受托管的线程与 Windows线程 4.3 抢占式多任务处理 4.3 进程与线程的优先级 进程,线程 操作系统的设计，因此可以归结为三点： 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 进程状态：进程有三个状态，就绪，运行和阻塞。 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/process-node-sync.html":{"url":"src/process-node-sync.html","title":"阻塞与非阻塞","keywords":"","body":"阻塞与非阻塞 怎麼理解阻塞和非阻塞的區別？ 1. 同步和異步　　 同步和異步關注的是消息通信機制( synchronous communication/ asynchronous communication)所謂同步，就是在發出一個調用時，在沒有得到結果之前，該-調用-就不返回。但是一旦調用返回，就得得到返回值了。　　 換句話說，就是由-調用者-主動等待這個-調用-結果。　　 而異步則是相反，-調用-在發出之後，這個調用就直接得到結果。而是在-調用-發出後，-換句話說-當一個異步過程調用發出後，調用者不會立即得到結果。而是在-調用-發出後，-被調用者-通過狀態、通知來通知調用者，或通過灰調函數處理這個調用。　　 典型的異步編程比如Node.js 2. 阻塞和非阻塞阻塞和非阻塞關注的是程序在等待調用結果(消息，返回值)是的狀態。阻塞調用是指調用結果返回之前，但錢線程會被掛起。調用線程指頭在得到結果之後才會返回。非阻塞調用指在不能立刻得到結果之前，該調用不會阻塞當前線程。 　 阻塞與非阻塞、同步與異步I/O模型 　I/O 模型： 1. Linux 下的五中I/O模型 阻塞I/O 非阻塞I/O I/O 復用 信號驅動I/O 異步I/O 前四種都是同步，只有最後一種才是異步IO； 2. Windows 的異步I/O模型有下面六種 select選擇模型 WSAAsyncSelect 異步選擇模型 WSAEventSelect 事件選擇模型 Overlapped I/O 事件通知模型 Overlapped I/O 完成例程模型 IOCP 模型 Linux 的幾種I/O 模型介紹： 1. 阻塞I/O模型 進程會一直阻塞,直到數據拷貝完成應用程序調用一個I/O函數,導致應用程序阻塞,等待數據準備好.如果數據沒有準備好,一直等待...數據準備好了,從內核拷貝到用戶空間,I/O函數返回成功指示. 可能阻塞套接字的Windows Sockets API調用分爲以下四種: 輸入操作:recv(),recvfrom(),WSARecv() 和 WSARecvfrom() 函數. 以阻塞套接字爲參數調用該函數接收數據.如果此時套接字緩衝區內沒有數據刻度,則調用線程在數據到來前一直睡覺. 輸出操作:send(), sendto(), WSASend() 和 WSASendto() 函數.以阻塞套接字爲參數調用該函數發送數據.如果套接字緩衝區沒有可用空間,縣城會一直睡覺,直到有空間. 接受連接:accept() 和 WSAAccept() 函數.以阻塞套接字爲參數調用該函數,等待接受對方的連接請求.如果此時沒有連接請求,線程就會進入睡眠狀態. 外出連接:connect() 和 WSAConnect() 函數. 對於TCP鏈接,客戶端以阻塞套接字爲參數,調用該函數,調用該函數向服務器發起鏈接.該函數在收到服務器的贏大前,不會返回.這意味着TCP鏈接總會等待至少到服務器的一次往返時間. 2. 非阻塞I/O模型 非阻塞I/O 通過進程反復調用I/O函數(多次系統調用,並馬上返回);在數據拷貝的過程中,進程是阻塞的;我們把一個SOCKET接口設置爲非阻塞就是告訴內核,黨所請求的I/O操作無法完成時,不要將進程睡眠,而是返回一個錯誤,這樣我們的I/O操作函數將不斷的測試數據是否已經準備好了,如果沒有準備好,繼續測試,直到數據準備好爲止.在這個測試的過程中,會大量的佔用CPU的時間. 非阻塞套接字在控制建立的多個連接,在數據的收發量不均,時間不定時,明顯具有優勢.這種套接字在使用上存在一定難度,但只要排除這些困難,他在功能上還是非常強大的. 3. I/O復用模型 4. 信號驅動I/O模型5. 異步I/O模型6. 五種I/O模型比較 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/process-node-process.html":{"url":"src/process-node-process.html","title":"进程与线程优性能","keywords":"","body":"Node.js 通过进程、线程优化的性能 1. node.js 单线程的特点 node.js 以异步非阻塞单线程，作为其执行速度的保障。什么是非阻塞单线程？ 高性能（不用考虑多线程间来回调用引起性能的损耗） 线程安全（不用担心同意变量会被多线程进行读写而造成程序的崩溃） 底层多线程 说node.js 是单线程其实也是不全面的，node.js 底层库会使用libuv调用多线程来处理I/O 操作。这就像食堂只有一个窗口，只能有按顺序一个个的接收点餐，但是后厨配菜的员工却有很多，他们各司其职保证出餐的速度。 2.如何通过多线程提高node.js 的性能 cluster: 为了利用多核系统，用户有时会想启动一个 Node.js 进程的集群去处理负载。 3. 如何通过多进程提高node.js 的性能 Child Process 创建进程 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/database.html":{"url":"src/database.html","title":"数据库","keywords":"","body":"数据库 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/db-graphql.html":{"url":"src/db-graphql.html","title":"GraphQL","keywords":"","body":"GraphQL 概念解释 1. Schemaschema 定义了 GraphQL API 系统的类型系统.他完整描述了客户端可以访问的所有数据(对象,成员变量,关系,人很类型).客户端的请求将根据schema进行校验和执行.客户端可以通过\"自省\"(introspection)获取关于schema的信息.schema存放于GraphQL API服务器. 2. Fieldfield是你可以从对象中获取的数据单元。正如GraphQL官方文档所说：“GraphQL查询语言本质上就是从对象中选择field”。关于field，官方标准中还说：所有的GraphQL操作必须指明到最底层的field，并且返回值为标量，以确保响应结果的结构明白无误 标量（scalar）：基本数据类型也就是说，如果你尝试返回一个不是标量的field，schema校验将会抛出错误。你必须添加嵌套的内部field直至所有的field都返回标量。 3. Argumentargument是附加在特定field后面的一组键值对。某些field会要求包含argument。mutation要求输入一个object作为argument。 4. ImplementationGraphQL schema可以使用implement定义对象继承于哪个接口。 5. Connectionconnection让你能在同一个请求中查询关联的对象。通过connection，你只需要一个GraphQL请求就可以完成REST API中多个请求才能做的事。 为帮助理解，可以想象这样一张图：很多点通过线连接。这些点就是node，这些线就是edge。connection定义node之间的关系。 6. Edgeedge表示node之间的connection。当你查询一个connection时，你通过edge到达node。每个edgesfield都有一个nodefield和一个cursorfield。cursor是用来分页的。 7. Nodenode是对象的一个泛型。你可以直接查询一个node，也可以通过connection获取相关node。如果你指明的node不是返回标量，你必须在其中包含内部field直至所有的field都返回标量。 基本使用 1. 发现GraphQL APIGraphQL是可自省的，也就是说你可以通过查询一个GraphQL知道它自己的schema细节。 查询__schema以列出所有该schema中定义的类型，并获取每一个的细节：query { __schema { types { name kind description fields { name } } } } 查询__type以获取任意类型的细节：query { __type(name: \"Repository\") { name kind description fields { name } } } 提示：自省查询可能是你在GraphQL中唯一的GET请求。不管是query还是mutation，如果你要传递请求体，GraphQL请求方式都应该是POST 2. GraphQL 授权要与GraphQL服务器通讯，你需要一个对应权限的OAuth token。 通过命令行创建个人access token的步骤详见这里。你访问所需的权限具体由你请求哪些类型的数据决定。比如，选择User权限以获取用户数据。如果你需要获取版本库信息，选择合适的Repository权限。 当某项资源需要特定权限时，API会通知你的。 3. GraphQL 端点REST API v3有多个端点，GraphQL API v4则只有一个端点： https://api.github.com/graphql 不管你进行什么操作，端点都是保持固定的。 4. GraphQL 通讯在REST中，HTTP动词决定执行何种操作。在GraphQL中，你需要提供一个JSON编码的请求体以告知你要执行query还是mutation，所以HTTP动词为POST。自省查询是一个例外，它只是一个对端点的简单的GET请求。 5. 关于 query 和 mutation 操作在GitHub GraphQL API中有两种操作：query和mutation。将GraphQL类比为REST，query操作类似GET请求，mutation操作类似POST/PATCH/DELETE。mutation mame决定执行哪种改动。 query和mutation具有类似的形式，但有一些重要的不同 6. 关于 queryGraphQL query只会返回你指定的data。为建立一个query，你需要指定“fields within fields\"（或称嵌套内部field）直至你只返回标量。 query的结构类似： query { JSON objects to return } 7. 关于 mutation为建立一个mutation，你必须指定三样东西： mutation name：你想要执行的修改类型 input object：你想要传递给服务器的数据，由input field组成。把它作为argument传递给mutation name payload object：你想要服务器返回给你的数据，由return field组成。把它作为mutation name的body传入 mutation的结构类似： mutation { mutationName(input: {MutationNameInput!}) { MutationNamePayload } 此示例中input object为MutationNameInput，payload object为MutationNamePayload. 8. 使用 variablesvariables使得query更动态更强大，同时他能简化mutation input object的传值。 以下是一个单值variables的示例： query($number_of_repos:Int!) { viewer { name repositories(last: $number_of_repos) { nodes { name } } } } variables { \"number_of_repos\": 3 } 使用variables分为三步： 在操作外通过一个variables对象定义变量：对象必须是有效的JSON。此示例中只有一个简单的Int变量类型，但实际中你可能会定义更复杂的变量类型，比如input object。你也可以定义多个变量。 将变量作为argument传入操作： argument是一个键值对，键是$开头的变量名（比如$number_of_repos），值是类型（比如Int）。如果类型是必须的，添加!。如果你定义了多个变量，将它们以多参数的形式包括进来。 在操作中使用变量： 在此示例中，我们使用变量来代替获取版本库的数量。在第2步中我们指定了类型，因为GraphQL强制使用强类型。 这一过程使得请求参数变得动态。现在我们可以简单的在variables对象中改变值而保持请求的其它部分不变。 用变量作为argument使得你可以动态的更新variables中的值但却不用改变请求。 示例案例 1. query 示例以下query查找octocat/Hellow-World版本库，找到最近关闭的20个issue，并返回每个issue的题目、URL、前5个标签： query { repository(owner:\"octocat\", name:\"Hello-World\") { issues(last:20, states:CLOSED) { edges { node { title url labels(first:5) { edges { node { name } } } } } } } } 让我们一行一行的来看各个部分： query { 因为我们想要从服务器读取而不是修改数据，所以根操作为query。（如果不指定一个操作，默认为query） repository(owner:\"octocat\", name:\"Hello-World\") { 为开始我们的query，我们希望找到repository对象。schema校验指示该对象需要owner和name参数 issues(last:20, states:CLOSED) { 为计算该版本库的所有issue，我们请求issue对象。（我们可以请求某个repository中某个单独的issue，但这要求我们知道我所需返回issue的序号，并作为argument提供。） issue对象的一些细节： 根据文档，该对象类型为IssueConnection schema校验指示该对象需要一个结果的last或first数值作为argument，所以我们提供20 文档还告诉我们该对象接受一个states argument，它是一个IssueState的枚举类型，接受OPEN或CLOSED值。为了只查找关闭的issue，我们给states键一个CLOSED值。 edges { 我们知道issues是一个connection，因为它的类型为IssueConnection。为获取单个issue的数据，我们需要通过edges取得node。 node { 我们从edge的末端获取node。IssueConnection的文档指示IssueConnection类型末端的node是一个issue对象。 既然我们知道了我们要获取一个Issue对象，我们可以查找文档并指定我们想要返回的field： title url labels(first:5) { edges { node { name } } } 我们指定Issue对象的title，url，labels。 labels field类型为LabelConnection。和issue对象一样，由于labels是一个connection，我们必须遍历它的edge以到达连接的node：label对象。在node上，我们可以指定我们想要返回的label对象field，在此例中为name。 你可能注意到了在这个Octocat的公开版本库Hellow-World中运行这个query不会返回很多label。试着在你自己的有label的版本库中运行它，你就会看到差别了。 1. mutation 示例 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/mobile.html":{"url":"src/mobile.html","title":"移动端","keywords":"","body":"移动端 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/mini-program.html":{"url":"src/mini-program.html","title":"微信小程序","keywords":"","body":"微信小程序 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/mini-program-install.html":{"url":"src/mini-program-install.html","title":"微信小程序安装(linux)","keywords":"","body":"微信小程序安装(linux) Linux 微信小程序安装 linux 下使用微信web开发者工具. Description Linux微信web开发者工具, 可在 linux 桌面环境跑起 微信开发者工具, 原理是 微信开发者工具 本质是 nw.js 程序, 把它移植到 linux 下没大问题. 负责编译 wxml 和 wxss 的 wcc 和 wcsc (可能还有其他功能), 则利用 wine 来跑即可. Usage 下载项目和初始化 git clone https://github.com/cytle/wechat_web_devtools.git cd wechat_web_devtools # 自动下载最新 `nw.js` , 同时部署目录 `~/.config/wechat_web_devtools/` ./bin/wxdt install 启动ide，开发和调试网页 运行准备: GUI环境 ./bin/wxdt # 启动 启动ide，开发和预览小程序 运行准备: GUI环境 需要安装wine 并且已经执行过./bin/wxdt install ./bin/wxdt # 启动 命令行和HTTP调用 运行准备: GUI环境，命令行和HTTP调用会自动启动ide(服务器没条件的可以使用docker) 并且已经执行过./bin/wxdt install 在ide的设置中开启服务端口： 设置 -> 安全 -> 服务端口(开启) 命令行工具所在位置: /bin/cli 端口号文件位置：~/.config/wechat_web_devtools/Default/.ide 微信文档参考: 命令行 调用 · 小程序 HTTP 调用 · 小程序 Docker docker run --name wxdt -d -P -p 6080:80 --mount type=bind,source=$PWD,target=/weapps canyoutle/wxdt # 必须: 打开 http://localhost:6080 进入图形界面 docker exec -it wxdt cli -l # 登录 docker exec -it wxdt cli -p /weapps/wechat-v2ex # 预览工程 其它说明 安装Wine 请参考搜索引擎安装 Wine，以下是Ubuntu下两种安装 1. 安装wine-binfmt sudo apt-get install wine-binfmt sudo update-binfmts --import /usr/share/binfmts/wine 2. 正常安装wine dpkg --add-architecture i386 \\ && wget -nc https://dl.winehq.org/wine-builds/winehq.key \\ && apt-key add winehq.key \\ && apt-add-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ bionic main' \\ && apt-get update \\ && apt-get install -y --no-install-recommends --allow-unauthenticated winehq-stable ./bin/wxdt install 报错失败 ./nw: error while loading shared libraries: libnw.so: cannot open shared object file: No such file or directory 该错误是由 nw.js 下载失败所致. 删除缓存, 重新下载即可. rm -rf /path/to/wechat_web_devtools/dist rm -rf /tmp/wxdt_xsp # 请务必等待执行完成 ./bin/wxdt install 参考 https://github.com/cytle/wechat_web_devtools/issues/49#issuecomment-350478295 wcc 和 wcsc 编译错误 是wine没安装好导致的，或是没有成功替换wcc 和 wcsc两个二进制文件 方案一: 安装wine并且执行./bin/wxdt install 方案二: 安装wine-binfmt 完成后, 点击 编译 即可. 参考: https://github.com/cytle/wechat_web_devtools/issues/66#issuecomment-368434141 https://github.com/cytle/wechat_web_devtools/issues/56#issuecomment-371999385 更新到最新版 方案一: 直接从当前项目源码 进行 更新 (稳定, 推荐) git pull origin 方案二: 使用腾讯原始安装程序 进行 自助复制更新 (及时, 自行折腾) 注: 如果抽风了, 可以尝试使用 git reset --hard 等操作, 还原到最初的状态. 执行更新, 自动下载最新 Windows x64 版开发者工具, 并且使用7z解压. ./bin/update_package_nw.sh Tips 运行没问题，欢迎PR Ubuntu环境下编辑器字体安装 Ubuntu环境下默认没有Cosolas字体，同时目前无法修改字体，因此下载安装Consolas字体是较优方案，使得编辑器将显示更舒服。 下载https://github.com/kakkoyun/linux.files/raw/master/fonts/Consolas.ttf 至/usr/local/share/fonts or ~/.fonts sudo fc-cache -f重建字体缓存 确认字体安装成功 sudo fc-list|grep Consol .fonts/Consolas.ttf: Consolas:style=Regular 重启微信开发者工具 卸载 关闭 微信web开发者工具 项目文件夹下运行 ./bin/wxdt uninstall (删除桌面图标、微信web开发者工具配置目录), 开发者工具配置文件, 所有工程和登录信息均会消失 删除项目文件夹 截图 上面项目来自wechat-v2ex Changelog 更新日志 腾讯官方更新日志 Author cytle powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/mini-program-thirdparty.html":{"url":"src/mini-program-thirdparty.html","title":"小程序第三方框架","keywords":"","body":"小程序第三方框架 wepy / mpvue / taro 小程序开发有哪些痛点 频繁调用 setData及 setData过程中页面跳闪 组件化支持能力太弱(几乎没有) 不能使用 less、scss 等预编译器 request 并发次数限制 为什么使用第三方框架 只要熟悉vue或react即可快速上手,学习成本低 一套代码可在多端编译运行(微信,支付宝,h5,RN) 支付宝小程序暂不完善 组件化开发，完美解决组件隔离，组件嵌套，组件通信等问题 支持使用第三方 npm 资源 使小程序可支持 Promise，解决回调烦恼 可使用 Generator Fu-nction / Class / Async Function 等特性，提升开发效率 对小程序本身的优化，如生命周期的补充，性能的优化等等 支持样式编译器: Scss/Less，模板编译器，代码编译器：Babel/Typescript 第三方框架对比 wepy mpvue taro WEPY MpVue Taro 生命周期 同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同 wepy 这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。 import wepy from 'wepy'; export default class MyPage extends wepy.page { // export default class MyComponent extends wepy.component { customData = {} // 自定义数据 customFunction ()　{} //自定义方法 onLoad () {} // 在Page和Component共用的生命周期函数 onShow () {} // 只在Page中存在的页面生命周期函数 config = {}; // 只在Page实例中存在的配置数据，对应于原生的page.json文件 data = {}; // 页面所需数据均需在这里声明，可用于模板数据绑定 components = {}; // 声明页面中所引用的组件，或声明组件中所引用的子组件 mixins = []; // 声明页面所引用的Mixin实例 computed = {}; // 声明计算属性（详见后文介绍） watch = {}; // 声明数据watcher（详见后文介绍） methods = {}; // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明 events = {}; // 声明组件之间的事件处理函数 } mpvue mpvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子 1Vue beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestroy destroyed app 部分 onLaunch，初始化 onShow，当小程序启动，或从后台进入前台显示 onHide，当小程序从前台进入后台 page 部分 onLoad，监听页面加载 onShow，监听页面显示 onReady，监听页面初次渲染完成 onHide，监听页面隐藏 onUnload，监听页面卸载 onPullDownRefresh，监听用户下拉动作 onReachBottom，页面上拉触底事件的处理函数 onShareAppMessage，用户点击右上角分享 onPageScroll，页面滚动 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持） new Vue({ data: { a: 1 }, created () { // `this` 指向 vm 实例 console.log('a is: ' + this.a) }, onShow () { // `this` 指向 vm 实例 console.log('a is: ' + this.a, '小程序触发的 onshow') } }) // => \"a is: 1\" taro taro与react生命周期完全相同 class Clock extends Component { constructor (props) { super(props) this.state = { date: new Date() } } componentDidMount() { } componentWillUnmount() { } render () { return ( Hello, world! 现在的时间是 {this.state.date.toLocaleTimeString()}. ) } } 参考文献 小程序第三方框架对比 ( wepy / mpvue / taro ) powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-dev.html":{"url":"src/tool-dev.html","title":"开发工具","keywords":"","body":"开发工具 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-install.html":{"url":"src/tool-install.html","title":"开发工具安装","keywords":"","body":"开发工具安装 dia 工具 alias dia=\"env GTK_IM_MODULE=xim dia\" 微信小程序开发者工具 sudo git clone https://github.com/cytle/wechat_web_devtools.git nvm 安装 # 1 ubuntu curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash # 2 ubuntu wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash nrm 安装 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-vim.html":{"url":"src/tool-vim.html","title":"Vim Command Collection","keywords":"","body":"History Command 以:和/开头的命令都有历史记录，可以首先键入:或/然后按上下箭头来选择某个历史命令。 Start Vim 在命令行窗口中输入以下命令即可vim filename File Command vim file vim file1 file2 file3... :open file :split file :bn :bp :args :e ftp:192.168.10.76/abc.txt Insert Command i I Search Command Replacement Command Move Command Undo And Redo Delete Command Copy And Paste Cute Command Exit Command Window Command Shell Command Annotation Command Help Command Other Command powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-git.html":{"url":"src/tool-git.html","title":"Git","keywords":"","body":"Git powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-git-commit_rule.html":{"url":"src/tool-git-commit_rule.html","title":"Git Rule","keywords":"","body":"Git Rule 具体规则 (): type 用于说明 commit 的类别，只允许使用下面7个标识 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 scope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同 subject 是 commit 目的的简短描述，不超过50个字符 以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号(.) 项目中使用 Node 插件 validate-commit-msg ,检查项目中 Commit message 是否规范 使用方式 建立 .vcmrc 文件: { \"types\": [\"feat\", \"fix\", \"docs\", \"style\", \"refactor\", \"perf\", \"test\", \"build\", \"ci\", \"chore\", \"revert\"], \"scope\": { \"required\": false, \"allowed\": [\"*\"], \"validate\": false, \"multiple\": false }, \"warnOnFail\": false, \"maxSubjectLength\": 100, \"subjectPattern\": \".+\", \"subjectPatternErrorMsg\": \"subject does not match subject pattern!\", \"helpMessage\": \"\", \"autoFix\": false } 写入 package.json { \"config\": { \"validate-commit-msg\": { /* your config here */ } } } 自动使用 ghooks 钩子函数 TODO: 详解 { … \"config\": { \"ghooks\": { \"pre-commit\": \"gulp lint\", \"commit-msg\": \"validate-commit-msg\", \"pre-push\": \"make test\", \"post-merge\": \"npm install\", \"post-rewrite\": \"npm install\", … } } … } Commit 规范的作用 提供更多的信息，方便排查与回退; 过滤关键字，迅速定位; 方便生成文档; 生成 Change log 生成的文档包括以下三个部分: New features Bug fixes Breaking changes. 使用工具 Conventional Changelog 生成 Change log ： npm install -g conventional-changelog cd jartto-domo conventional-changelog -p angular -i CHANGELOG.md -w powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-git-submodule.html":{"url":"src/tool-git-submodule.html","title":"Git Submodule","keywords":"","body":"Git Submodule 翻译自 git docs Name git-submodule - Initialize, update or inspect submodulesgit submodule 命令可以初始化、更新、和检查 git 子模块 Synopsis git submodule [--quiet] [--cached] git submodule [--quiet] add [\\] [--] \\ [\\] git submodule [--quiet] status [--cached] [--recursive] [--] [\\…​] git submodule [--quiet] init [--] [\\…​] git submodule [--quiet] deinit [-f|--force] (--all|[--] \\…​) git submodule [--quiet] update [\\] [--] [\\…​] git submodule [--quiet] set-branch [\\] [--] \\ git submodule [--quiet] summary [\\] [--] [\\…​] git submodule [--quiet] foreach [--recursive] \\ git submodule [--quiet] sync [--recursive] [--] [\\…​] git submodule [--quiet] absorbgitdirs [--] [\\…​] Description Inspects, updates and manages submodules powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-git-gitignore.html":{"url":"src/tool-git-gitignore.html","title":"gitignore","summary":"可以指定git提交忽略的文件路径","keywords":"","body":"gitignore Pattern Format 空行不匹配任何文件，因此可以使用空行作为分隔符来提高可读性 # 用在开头的表明该行是注释，用 hash 开头的行需要使用 \\ 转义 尾随空格会被忽略，除非使用引号包裹 + \\ 转义 ! 感叹号用来否定当前模式，即不忽略匹配到的文件 \\ 用作文件夹分隔符，他可以出现在模式中的开头、中间和结尾。 如果模式结尾存在\\ ，匹配的是文件夹 如果模式结尾不存在\\，则匹配的是文件夹和文件 * 星号可用于匹配任何东西不包括斜杠 \\ ? 问号可用于匹配任何一个字符不包括斜杠 \\ [a-zA-Z] 范围符号可用于匹配范围内一个字符（有关更多详情说明请参考 fnmatch(3) 和 FNM_PATHNAME） ** 在不同的使用场景中具有不同的意义 前导 ** 后跟随 \\,表示在目录中匹配。例如：\"**/foo\" === \"foo\" 尾随 ** 前是 \\,表示匹配目录下所有内容。例如： \"abc/**\" 表示匹配abc 目录下的所有内容 \\ 后跟随 ** 并且后续 \\ 匹配一个或多个目录。例如：\"a/**/b\" === \"a/x/b\" || \"a/x/y/b\" 等等 其他连续的星号被视为常规星号，并将根据之前的规则进行匹配 Reference Git Doc powered by Gitbook文件修改于： 2020-04-02 21:46:12 "},"src/tool-lerna.html":{"url":"src/tool-lerna.html","title":"Lerna","keywords":"","body":"Lerna 模式 Fixed/Locked mode (default) 在publish的时候,会在lerna.json文件里面\"version\": \"0.1.5\",,依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号 Independent mode lerna init --independent初始化项目。 lerna.json文件里面\"version\": \"independent\", 每次publish时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改 Lerna Script lerna create [loc] 创建一个包，name包名，loc 位置可选 ```c 根目录的package.json \"workspaces\": [ \"packages/\", \"packages/@gp0320/\" ], 创建一个包gpnote默认放在 workspaces[0]所指位置 lerna create gpnote 创建一个包gpnote指定放在 packages/@gp0320文件夹下，注意必须在workspaces先写入packages/@gp0320，看上面 lerna create gpnote packages/@gp0320 ### lerna add [@version] [--dev] [--exact] > 增加本地或者远程package做为当前项目packages里面的依赖 ```c # Adds the module-1 package to the packages in the 'prefix-' prefixed folders lerna add module-1 packages/prefix-* # Install module-1 to module-2 lerna add module-1 --scope=module-2 # Install module-1 to module-2 in devDependencies lerna add module-1 --scope=module-2 --dev # Install module-1 in all modules except module-1 lerna add module-1 # Install babel-core in all modules lerna add babel-core lerna bootstrap 默认是npm i lerna list 列出所有的包，如果与你文夹里面的不符，进入那个包运行yarn init -y解决 lerna import 导入本地已经存在的包 lerna run lerna run -- [..args] # 运行所有包里面的有这个script的命令 $ lerna run --scope my-component test lerna exec $ lerna exec -- [..args] # runs the command in all packages $ lerna exec -- rm -rf ./node_modules $ lerna exec -- protractor conf.js lerna exec --scope my-component -- ls -la lerna link 项目包建立软链，类似npm link lerna clean 删除所有包的node_modules目录 lerna changed 列出下次发版lerna publish 要更新的包 原理： 需要先git add,git commit 提交。 然后内部会运行git diff --name-only v版本号，搜集改动的包，就是下次要发布的。并不是网上人说的所有包都是同一个版全发布 lerna publish 会打tag，上传git,上传npm。 如果你的包名是带scope的例如：\"name\": \"@gp0320/gpwebpack\", 那需要在packages.json添加 \"publishConfig\": { \"access\": \"public\" }, reference Lerna 中文教程详解 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/tool-ubuntu-env.html":{"url":"src/tool-ubuntu-env.html","title":"Ubuntu开发环境安装","keywords":"","body":"Ubuntu开发环境安装 更改apt源 复制源文件备份 /etc/apt/source.list 编辑源文件 查看系统版本信息 替换原有内容 更新软件列表、软件包sudo apt-get update sudo apt-get upgrade // 中科大源 deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse // 阿里源 deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse // 163源 deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse // 清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 安装zsh sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" oh-my-zsh 插件 extract ruby zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting autojump git 安装 nvm sudo apt-get update sudo apt-get install build-essential libssl-dev curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash 安装 yarn curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update && sudo apt-get install yarn powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/ops.html":{"url":"src/ops.html","title":"运维测试","keywords":"","body":"运维测试 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/ops-nightwatch.html":{"url":"src/ops-nightwatch.html","title":"Nightwatch","keywords":"","body":"nightwatch nightwatch.js是一个web-ui自动化测试框架 所需环境 项目配置 注意 API Reference 引文 所需环境 npm intall nightwatch -D // selenium-server是基于Java开发的，作用是用来连接浏览器的 npm install selenium-server -D // 浏览器驱动器 npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedrive -D 项目配置 module.exports = { 'src_folders': [ 'e2e/case' ], 'output_folder': 'reports', 'custom_commands_path': '', 'custom_assertions_path': '', 'page_objects_path': '', 'globals_path': require('./e2e/config/global.config').path, 'selenium': { 'start_process': true, 'server_path': require('selenium-server').path, 'log_path': '', 'host': '127.0.0.1', 'port': 4444, 'cli_args': { 'webdriver.chrome.driver': require('chromedriver').path } }, 'test_settings': { 'default': { 'launch_url': 'http://localhost', 'selenium_port': 4444, 'selenium_host': 'localhost', 'silent': true, 'screenshots': { 'enabled': false, 'path': '' }, 'desiredCapabilities': { 'browserName': 'chrome', 'marionette': true } }, 'chrome': { 'desiredCapabilities': { 'browserName': 'chrome' } }, 'edge': { 'desiredCapabilities': { 'browserName': 'MicrosoftEdge' } } } } src_folders：表示的就是case所在的文件夹 output_folder：代表的是报告输出的文件夹 selenium下面的server_path：代表的是selenium-server的安装路径 selenium下面的start_process：代表的是是否自动启动selenium——server,入股设为false,不会自动启动server。 cli_args下面的driver表示几个driver的安装路径，分别安装成功就可以了 test_settings是传给nightwatch实例的数据，这里面可以配置多个环境，default是必须有的，其他环境可以自行配制。 注意 在windows发现报错了，运行不起来的。我们需要在package.json下面配置一下 API 中 selector ---> CSS / Xpath cssSelector ---> CSS API Reference Expect Nightwatch provides a fluent BDD-style interface for performing assertions on elements, defined on the expect namespace on the main Nightwatch instance(Nightwatch提供了一个流畅的BDD风格的界面，用于对元素进行断言，在主要的Nightwatch实例上的expect命名空间中定义) this.demoTest = function (browser) { // start with identifying the element // and then assert the element is present browser.expect.element('#main').to.be.present; // or assert the element is visible browser.expect.element('#main').to.be.visible; }; Language Chains to be been is that which and has have with at does of .equal(value)/.contain(value)/.match(regex) These methods will perform assertions on the specified target on the current element. The targets can be an attribute value, the element's inner text and a css property(这些方法将在当前元素的指定目标上执行断言。目标可以是属性值，元素的内部文本和css属性) this.demoTest = function (browser) { browser.expect.element('#main').text.to.equal('The Night Watch'); browser.expect.element('#main').text.to.contain('The Night Watch'); browser.expect.element('#main').to.have.css('display').which.equals('block'); }; .startsWith(value)/.endsWith(value) this.demoTest = function (browser) { browser.expect.element('#main').text.to.endWith('Watch'); browser.expect.element('#main').text.to.startWith('The'); }; .not this.demoTest = function (browser) { browser.expect.element('#main').text.to.not.equal('The Night Watch'); browser.expect.element('#main').text.to.not.contain('The Night Watch'); browser.expect.element('#main').to.have.css('display').which.does.not.equal('block'); }; .before(ms)/.after(ms) These methods perform the same thing which is essentially retrying the assertion for the given amount of time (in milliseconds). before or after can be chained to any assertion and thus adding retry capability(这些方法执行相同的操作，基本上是在给定的时间量（以毫秒为单位）重试断言。之前或之后可以链接到任何断言，从而添加重试功能) this.demoTest = function (browser) { browser.expect.element('#main').text.to.contain('The Night Watch').before(1000); browser.expect.element('#main').text.to.not.contain('The Night Watch').after(500); }; .a(type [, message]) this.demoTest = function (browser) { browser.expect.element('#q').to.be.an('input'); browser.expect.element('#q').to.be.an('input', 'Testing if #q is an input'); browser.expect.element('#w').to.be.a('span'); } .attribute(name [, message]) this.demoTest = function (browser) { browser.expect.element('body').to.have.attribute('data-attr'); browser.expect.element('body').to.not.have.attribute('data-attr'); browser.expect.element('body').to.not.have.attribute('data-attr', 'Testing if body does not have data-attr'); browser.expect.element('body').to.have.attribute('data-attr').before(100); browser.expect.element('body').to.have.attribute('data-attr') .equals('some attribute'); browser.expect.element('body').to.have.attribute('data-attr') .not.equals('other attribute'); browser.expect.element('body').to.have.attribute('data-attr') .which.contains('something'); browser.expect.element('body').to.have.attribute('data-attr') .which.matches(/^something\\ else/); }; .css(property [, message]) this.demoTest = function (browser) { browser.expect.element('#main').to.have.css('display'); browser.expect.element('#main').to.have.css('display', 'Testing for display'); browser.expect.element('#main').to.not.have.css('display'); browser.expect.element('#main').to.have.css('display').before(100); browser.expect.element('#main').to.have.css('display').which.equals('block'); browser.expect.element('#main').to.have.css('display').which.contains('some value'); browser.expect.element('#main').to.have.css('display').which.matches(/some\\ value/); }; .enabled Property that checks if an element is currently enabled.(检查当前是否启用了元素的属) this.demoTest = function (browser) { browser.expect.element('#weblogin').to.be.enabled; browser.expect.element('#main').to.not.be.enabled; browser.expect.element('#main').to.be.enabled.before(100); }; .present Property that checks if an element is present in the DOM.(检查DOM中是否存在元素的属性) this.demoTest = function (browser) { browser.expect.element('#main').to.be.present; browser.expect.element('#main').to.not.be.present; browser.expect.element('#main').to.be.present.before(100); }; .selected Property that checks if an OPTION element, or an INPUT element of type checkbox or radio button is currently selected.(检查当前是否选中OPTION元素或类型为复选框或单选按钮的INPUT元素的属性。) this.demoTest = function (browser) { browser.expect.element('#main').to.be.selected; browser.expect.element('#main').to.not.be.selected; browser.expect.element('#main').to.be.selected.before(100); }; .text this.demoTest = function (browser) { browser.expect.element('#main').text.to.equal('The Night Watch'); browser.expect.element('#main').text.to.not.equal('The Night Watch'); browser.expect.element('#main').text.to.equal('The Night Watch').before(100); browser.expect.element('#main').text.to.contain('The Night Watch'); browser.expect.element('#main').text.to.match(/The\\ Night\\ Watch/); }; .value Property that retrieves the value (i.e. the value attributed) of an element. Can be chained to check if contains/equals/matches the specified text or regex(检索元素的值（即属性值）的属性。可以链接以检查是否包含/ equals /匹配指定的文本或正则表达式) this.demoTest = function (browser) { browser.expect.element('#q').to.have.value.that.equals('search'); browser.expect.element('#q').to.have.value.not.equals('search'); browser.expect.element('#q').to.have.value.which.contains('search'); browser.expect.element('#q').to.have.value.which.matches(/search/); }; .visible Property that asserts the visibility of a specified element.(断言指定元素可见性的属性。) this.demoTest = function (browser) { browser.expect.element('#main').to.be.visible; browser.expect.element('#main').to.not.be.visible; browser.expect.element('#main').to.be.visible.before(100); }; Assert .assert when an assertion fails, the test ends, skipping all other assertions.(当断言失败时，测试结束，跳过所有其他断言) .verify when an assertion fails, the test logs the failure and continues with other assertions.(当断言失败时，测试记录失败并继续其他断言) client.assert.visible('.non_existing'); client.verify.visible(\".non_existing\"); Node.js Assert Module Nightwatch.js extends Node.js assert module, so you can also use any of the available methods there in your tests.(Nightwatch.js扩展了Node.js断言模块，因此您还可以在测试中使用任何可用的方法。) Automatically retrying failed assertions setting the property retryAssertionTimeout (in milliseconds) in the globals file. Example: retryAssertionTimeout = 2000 .attributeContains(String selector, String attribute, String expected [, String message]) Checks if the given attribute of an element contains the expected value.(检查元素的给定属性是否包含期望值) selector CSS / Xpath this.demoTest = function (browser) { browser.assert.attributeContains('#someElement', 'href', 'google.com'); }; .attributeEquals(String cssSelector, String attribute, String expected [, String msg]) Checks if the given attribute of an element has the expected value.(检查元素的给定属性是否具有期望值) cssSelector CSS this.demoTest = function (browser) { browser.assert.attributeEquals(\"body\", \"data-attr\", \"some value\"); }; .containsText(String cssSelector, String expectedText [, String msg]) Checks if the given element contains the specified text.() this.demoTest = function (browser) { browser.assert.containsText(\"#main\", \"The Night Watch\"); }; .cssClassPresent(String cssSelector, String className [, String msg]) Checks if the given element has the specified CSS class.(检查给定元素是否具有指定的CSS类) this.demoTest = function (browser) { browser.assert.cssClassPresent(\"#main\", \"container\"); }; .cssClassNotPresent(String cssSelector, String className [, String msg]) Checks if the given element does not have the specified CSS class.(检查给定元素是否没有指定的CSS类) this.demoTest = function (browser) { browser.assert.cssClassNotPresent(\"#main\", \"container\"); }; .cssProperty(cssSelector, cssProperty, expected [, msg]) Checks if the specified css property of a given element has the expected value.(检查给定元素的指定css属性是否具有期望值) this.demoTest = function (browser) { browser.assert.cssProperty(\"#main\", \"display\", \"block\"); }; .elementPresent(cssSelector [, msg]) Checks if the given element exists in the DOM(检查DOM中是否存在给定元素) this.demoTest = function (browser) { browser.assert.elementPresent(\"#main\"); }; .elementNotPresent(cssSelector [, msg]) Checks if the given element does not exist in the DOM.(检查DOM中是否存在给定元素) this.demoTest = function (browser) { browser.assert.elementNotPresent(\".should_not_exist\"); }; .hidden(cssSelector [, msg]) Checks if the given element is not visible on the page.(检查给定元素是否在页面上不可见) this.demoTest = function (browser) { browser.assert.hidden(\".should_not_be_visible\"); }; .title(expected [, msg]) Checks if the page title equals the given value.(检查页面标题是否等于给定值) this.demoTest = function (browser) { browser.assert.title(\"Nightwatch.js\"); }; .urlContains(expectedText [, msg]) Checks if the current URL contains the given value.(检查当前URL是否包含给定值) this.demoTest = function (browser) { browser.assert.urlContains('google'); }; .urlEquals(expected [, msg]) this.demoTest = function (browser) { browser.assert.urlEquals('http://www.google.com'); }; .value(cssSelector, expectedText [, msg]) Checks if the given form element's value equals the expected value.(检查给定表单元素的值是否等于预期值) this.demoTest = function (browser) { browser.assert.value(\"form.login input[type=text]\", \"username\"); }; .valueContains(cssSelector, expectedText [, msg]) Checks if the given form element's value contains the expected value.(检查给定表单元素的值是否包含期望值) this.demoTest = function (browser) { browser.assert.valueContains(\"form.login input[type=text]\", \"username\"); }; .visible(cssSelector [, msg]) Checks if the given element is visible on the page.(检查给定元素是否在页面上可见) this.demoTest = function (browser) { browser.assert.visible(\".should_be_visible\"); }; Page Object API Page objects provide an additional layer of abstraction for test case creation(页面对象为测试用例创建提供了额外的抽象层) module.exports = { // can be string or function url: function () { return this.api.launchUrl; }, elements: { // shorthand, specifies selector mySubmitButton: 'input[type=submit]' // full myTextInput: { selector: 'input[type=text]', locateStrategy: 'css selector' } }, commands: [ { myCustomPause: function () { this.api.pause(this.props.myPauseTime); } } ], // object version (best considered immutable) props: { myPauseTime: 1000 }, sections: { myFooterSection: { selector: '#my-footer', locateStrategy: 'css selector', elements: { myLogo: { selector: '.my-logo', locateStrategy: 'css selector' } }, commands: [ { myMoveToLogo: function () { this.moveToElement('@myLogo', this.props.myLogoX, this.props.myLogoY); } } ], // function version (recommended) props: function () { return { myLogoX: 10, myLogoY: 10 }; }, sections: { // additional, nested sections } } } }; Page Object Module(页面对象模块) Name Type description commands Array A list of objects containing functions to represent methods added to the page object instance commands Array 包含函数的对象列表，用于表示添加到页面对象实例的方法 elements Object/Array An object, or array of objects, of named element definitions to be used as element selectors within element commands called from the page object elements Object/Array 命名元素定义的对象或对象数组，用作从页面对象调用的元素命令中的元素选择器 props Object/Function An object or a function returning an object representing a container for user variables. Props objects are copied directly into the props property of the page object instance. props Object/Function 返回表示用户变量容器的对象的对象或函数。 Props对象被直接复制到页面对象实例的props属性中 sections Object An object of named sections definitions defining the sections within the page object. sections Object 命名节定义的对象，用于定义页面对象中的节 url String/Function A url or function returning a url to be used in a url() command when the page's navigate() method is called. url String/Function 调用页面的navigate（）方法时返回url（）命令中使用的url或函数的url或函数 Page Object Instance 页面对象模块定义用于在调用标准命令API的页面引用中的各自工厂函数时定义页面对象实例 const myPageObject = browser.page.MyPage(); // defined in MyPage.js module Properties Name Type description api Object 提供对完整Nightwatch命令API的访问的参考，通常在测试用例中称为浏览器。这用于访问那些不属于页面对象API中命令子集的命令 elements Object 元素选择器使用的Element对象的映射 name Object 页面对象的名称由其模块名称定义（不包括扩展名）。这与用于从命令API中的页面引用访问页面对象工厂的名称相同 props Object 对从模块定义分配的props对象的引用 section Object 为页面对象定义的Sections对象的映射。这将只包含页面对象模块的根节定义中的节。嵌套部分可通过其父部分自己的部分参考来访问 url String\\Function 来自页面对象模块的url值，可以是字符串，也可以是函数，具体取决于它在那里的定义方式 Methods .navigate() 使用命令API的url（）命令导航到为页面对象定义的已解析URL,在处理页面对象时，通常使用此命令代替命令API的url（），因为页面对象的url成员是用户定义的url字符串或函数，而不是用于导航到url的调用 Element Instances 元素实例封装用于处理元素选择器的定义,通常，您不需要直接访问它们，而是使用@ -prefixed名称来引用它们，但是它们可以通过页面对象或节的元素属性获得 Section Instances 页面对象部分实例是从页面对象实例的section属性访问的（请注意，这是“section”的单数形式，而复数版本“sections”在模块定义中使用）,节通过页面对象工厂自动创建，可直接作为节参考中的属性使用 const myPageObject = browser.page.MyPage(); const mySection = myPageObject.section.MySection; // from a `sections: {}` block in page object Page Object Commands All the Nightwatch command and assertions API is inherited by page objects(所有Nightwatch命令和断言API都由页面对象继承) Custom Commands Name Type description commands Array 包含函数的对象列表，用于表示添加到页面对象实例的方法 页面对象命令注意事项: Access(访问) 页面对象命令在页面对象模块中定义。它们可以位于命令列表中的模块根对象中，也可以位于节定义内（也可以位于命令中），但仅存在于它们所在的定义中 模块根命令中的页面对象命令在子节中不可用，并且节命令在父节或根页对象中不可用 Context(上下文) 页面对象命令上下文（this的值）是页面对象（对于节对象的节对象） Execution(执行) 不从命令队列中调用页面对象命令。调用函数时，会立即执行页面对象命令中的代码 Chaining(链接) 页面对象命令必须返回链接值。这可以是任何东西，但建议您坚持这一点，以允许您的命令在页面对象实例的上下文中链接 Commands 引文 官网nightwatch 关于Nightwatch selenium download powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/ops-jest.html":{"url":"src/ops-jest.html","title":"Jest","keywords":"","body":"jest Jest 对象 jest 对象自动挂载到每个测试文件的上下文。 jest对象中的方法有助于创建模拟并让您控制Jest的整体行为 方法 jest.clearAllTimers() jest.disableAutomock() jest.enableAutomock() jest.fn(implementation) jest.isMockFunction(fn) jest.genMockFromModule(moduleName) jest.mock(moduleName, factory, options) jest.unmock(moduleName) jest.doMock(moduleName, factory, options) jest.dontMock(moduleName) jest.clearAllMocks() jest.resetAllMocks() jest.restoreAllMocks() jest.resetModules() jest.runAllTicks() jest.runAllTimers() jest.runTimersToTime(msToRun) jest.runOnlyPendingTimers() jest.setMock(moduleName, moduleExports) jest.setTimeout(timeout) jest.useFakeTimers() jest.useRealTimers() jest.spyOn(object, methodName) powered by Gitbook文件修改于： 2019-10-10 16:35:44 "},"src/idea.html":{"url":"src/idea.html","title":"算法/数学/架构","keywords":"","body":"算法/数学/架构 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/idea-design-mode.html":{"url":"src/idea-design-mode.html","title":"设计模式","keywords":"","body":"设计模式 设计模式 DIP、IoC、DI、JS 依赖反转原则 控制反转 依赖注入 reference DIP、IoC、DI、JS 依赖反转原则 依赖反转原则（Dependency inversion principle，DIP），是一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。———— 维基百科 该原则规定： 高层次的模块不应该依赖与低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口 DIP 只是解决了高层次模块直接依赖低层次模块的问题, 但是存在依赖关系创建于高层次模块的问题 控制反转 控制反转（Inversion of Control，IoC），通过控制反转，对象在被创建的时候，有一个控制系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。可以说，依赖被注入到对象中。———— 维基百科 将依赖对象的创建和绑定转移到被依赖对象类的外部来实现。实现控制反转最常见的方式是依赖注入，还有一种方式依赖查找 依赖注入 依赖注入（Dependency Injection，DI），在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端）。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务将会变成客户端的状态的一部分。传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求 把过程放在外面，将结果带入内部.对于依赖模块的模块，则把依赖作为参数使用 reference 从前端角度彻底搞懂 DIP、IoC、DI、JS powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/idea-architectural.html":{"url":"src/idea-architectural.html","title":"架构设计经验分享","keywords":"","body":"架构设计经验分享 不要过设计： never over design 这是一个常常被提及的话题，但是只要想想你的架构里有多少功能是根本没有用到，或者最后废弃的，就能明白其重要性了，初涉架构设计，往往倾向于设计大而化一的架构，希望设计出具有无比扩展性，能适应一切需求的增加架构，web开发领域是个非常动态的过程，我们很难预测下个星期的变化，而又需要对变化做出最快最有效的响应。。 ebay的工程师说过，他们的架构设计从来都不能满足系统的增长，所以他们的系统永远都在推翻重做。请注意，不是ebay架构师的能力有问题，他们设计的架构总是建立旧版本的瓶颈上，希望通过新的架构带来突破，然而新架构带来的突破总是在很短的时间内就被新增需求淹没，于是他们不得不又使用新的架构 web开发，是个非常敏捷的过程，变化随时都在产生，用户需求千变万化，许多方面偶然性非常高，较之软件开发，希望用一个架构规划以后的所有设计，是不现实的。 web架构生命周期： web architecture's life cycle 缓存： Cache 核心模块一定要自己开发： 合理选择数据存储方式： 搞清楚谁是最重要的人： 不要执着于文档： 团队： powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/idea-front-end-archi.html":{"url":"src/idea-front-end-archi.html","title":"前端架构","keywords":"","body":"前端架构 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/idea-data-structure.html":{"url":"src/idea-data-structure.html","title":"基本数据结构","keywords":"","body":"基本数据结构 基本数据结构 TODO: 栈 栈的实现 栈要记录的数据 栈的操作 栈的应用 队列 队列的实现 队列要记录的数据 队列的操作 链表 链表种类 链表节点（Node）记录的数据 链表（LinkedList）记录的数据 链表的操作 哨兵（sentinel） 指针和对象的实现 树 树的种类 术语 堆 堆需要存储的数据 堆中元素通过坐标来确定父节点、左右子节点，具体来说 堆的分类 堆的操作 树结构与Java实现 参考文献 TODO: [ x ] 优先队列 [ x ] 堆 栈 栈是一种动态集合，它是一种LIFO（last in first out后进先出）结构 栈的实现 数组 链表 栈要记录的数据 栈顶位置top 注意这个top有两种理解方式，一种是表示栈的最后一个数据的位置，另一种是表示栈的最后一个数据的下一个位置，这两种理解对栈的操作代码有一定的影响 栈最大大小size 栈的操作 STACK_EMPTY（）：判断栈是否为空 PUSH（X）：向栈中添加一个值，注意栈是否为满的 POP（）：从栈中弹出一个值，注意栈是否为空 栈的应用 括号匹配问题 队列 与栈不同，它是一种FIFO（first in first out先进先出）结构 队列的实现 数组 链表 队列要记录的数据 队首位置head：第一个元素位置 队尾位置tail：下一个元素要插入的位置（最后一个元素的下一个位置） 队列最大大小size 队列的操作 ENQUEUE（x）：入队 DEQUEUE（）：出队 EMPTY（）：队列为空，head=tail FULL（）：队列为满，head=（tail+1）%size 链表 与数组中元素地址连续不同，链表中两个元素地址不一定连续，而是由专门的一个指针指明该元素的后一个（前一个）元素的地址 链表种类 单向链表：只有指向后一个元素的指针 双向链表：有指向后一个和前一个元素的指针 循环链表：链表内存在一个环 链表节点（Node）记录的数据 要存储的数据data 下一个节点地址Node* next 若是双向链表还要存储前一个节点地址Node prev 链表（LinkedList）记录的数据 链表的头指针Node head 可能还记录链表的尾指针 Node* tail 链表的操作 SEARCH(x)：链表的搜索 INSERT(i,x)：链表的插入，在第i个位置插入x DELETE（x）:链表的删除 哨兵（sentinel） 为了减少边界条件的判断（是否为空链表等等），引入哨兵，使得链表永远不为“空” 指针和对象的实现 用二维数组表示指针 我们可以设置一个n*3的数组记录n个节点，那个3就表示存储的数据、前一个元素的坐标（index）和后一个元素的坐标 用一维数组表示指针 树 树的种类 二叉树 二叉树要存储4个数据，分别是节点携带的信息和其父节点、左右子节点的指针 分支无限制的有根树 左孩子右兄弟表示法，这种方法每个节点设置3个指针：父指针、从左数第一个孩子的指针、其右侧相邻的兄弟指针 术语 路径 从某个节点依次到达另外一个节点所经过的所有节点，就是这两个节点之间的路径 根 树顶端的节点被称为根。从根出发到达任意一个节点只有一条路径 父节点 除了根节点之外，每个节点都可以向上找到一个唯一的节点，这个节点就是当前节点的父节点。相应的，父节点下方的就是子节点 叶子节点 没有子节点的“光杆司令”就被称为叶子节点 子树 每个子节点作为根节点的树都是一个子树 层 一个树结构的代数就是这个树的层 度 一棵树中，最大的节点的度称为树的度 兄弟节点 具有相同父节点的节点互称为兄弟节点 堆 堆实际上是以数组形式存储的二叉树 堆需要存储的数据 数组的大小max-size 堆元素个数size，这里size要小于max-size 堆中元素通过坐标来确定父节点、左右子节点，具体来说 一个节点i的父节点：[i/2]一个节点i的左子节点：[i2]一个节点i的右子节点：[i2+1] 堆的分类 最大堆 满足所有节点都比其父节点值小（小于等于）的堆A[i/2]>=A[i] 最小堆 满足所有节点都比其父节点值大（大于等于）的堆A[i/2] 堆的操作 维护堆的性质（HEAPIFY） 这里指维护最大堆或最小堆的性质。假设一个数组中下标为i的节点的子节点满足最大（小）堆性质，但自身不一定满足这个性质，这时就需要HEAPIFY，具体来说是要比较这个节点和其两个子节点的大小，将其中的大（小）的和该节点位置交换，这样这个节点及其两个子节点就满足最大（小）堆的性质了，但是可能交换后子节点不满足堆的性质，所以这里要递归调用HEAPIFY，直到达到最下层节点，这样就维护了堆的性质。HEAPIFY耗时O（lgn） 建堆（BUILD-HEAPIFY） 从中间那个元素开始到第一个元素，逐一调用HEAPIFY函数，即可完成建堆。 逐一从中间那个元素开始递减而不是从第一个元素递增，这时为了保证每次调用HEAPIFY都能保证该节点的子节点都满足最大（小）堆的性质，否则无法调用HEAPIFY。中间那个元素是第一个可能不满足最大（小）堆性质的节点，所以从这里开始维护（HEAPIFY）。建堆的期望时间为O（n） 树结构与Java实现 数组特点: 查询迅速,根据index可以快速定位到一个元素 对于插入和删除操作频繁的数据，不建议采用有序数组 链表的查询效率很低，每次都要从头开始找，依次访问链表的每个数据项 对于查找频繁的数据，不建议使用链表 参考文献 基本数据结构 树结构与Java实现 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "},"src/idea-func-programing.html":{"url":"src/idea-func-programing.html","title":"函数式编程","keywords":"","body":"函数式编程 powered by Gitbook文件修改于： 2019-09-20 10:51:48 "}}